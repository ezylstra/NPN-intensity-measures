---
title: "Exploration of intensity data"
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: "Erin Zylstra"
execute: 
  echo: false
  error: false
  warning: false
  message: false
format: 
  html:
    fig-cap-location: top
    page-layout: full
editor: visual
editor_options: 
  chunk_output_type: console
---

```{r}

library(dplyr)
library(stringr)
library(lubridate)
library(ggplot2)
library(cowplot)
library(kableExtra)
library(mgcv)
library(marginaleffects)
```

## Overview

To evaluate intensity data, we extracted observations of plants from Ellen Denny's site, and three NEON sites. At Ellen's site, we used observations of multiple plant species that comprise functional types. At BONA (NEON; AK) we're using observations of quaking aspen, at DEJU (NEON; AK) we're using obervations of dwarf birch, and at SRER (NEON; AZ) we're using observations of desert zinnia, velvet mesquite, and creosote bush.

We filtered the data by removing plant-year-phenophase combinations when:

-   there were no observations in phase (status always recorded as "no")
-   there were no observations with intensity values (rarely happened with plants in phase in these datasets)
-   there were fewer than 5 observations
-   the maximum interval between consecutive observations \> 14 days
-   the first observation occurred after the onset of most phenophases (2017 and 2020 at BONA; 2016 and 2020 at DEJU; and 2016 at SRER)

Other filtering steps:

-   excluded any species-phenophase combinations that were only represented by a single plant in a single year.
-   excluded intensity categories that were represented by a single intensity value
-   exluded intensity categories that had fewer than 50 observations across species, plants, and years

Intensities are reported in value ranges (e.g., 3-10 flowers; 25-49% open flowers). For analysis, we represented each intensity value by the approximate midpoint of the reported range (e.g., 5 flowers, 37% open flowers).

```{r setup}

# List of sites
sites <- c("bona", "deju", "srer", "ellen")

# Plant phenophase classes
leaf_classes <- 1:5
flower_classes <- 6:9
fruit_classes <- 10:13

# List files with formatted intensity data
intensity_files <- list.files("npn-data",
                              pattern = "intensity-site",
                              full.names = TRUE)
```

```{r load-filter-data}

# Summarize data available by species, individual, phenophase
for (site in sites) {
  
  sitecap <- str_to_upper(site)
  filename <- intensity_files[grepl(sitecap, intensity_files)]
  si <- read.csv(filename)

  # Remove any true duplicates
  si <- si[!duplicated(si),]
  
  # Occasionally there are two records for a plant-phenophase in one day with 
  # different intensity or status values. Removing these observations too.
  si <- si %>%
    group_by(individual_id, phenophase_id, observation_date) %>%
    mutate(n_obs = n()) %>%
    ungroup() %>%
    filter(n_obs == 1) %>%
    select(-n_obs) %>%
    data.frame()
  
  # Doublecheck that there's only one observation of each plant-phenophase per day
  if (nrow(si) != nrow(distinct(si, individual_id, phenophase_id, observation_date))) {
    warning("There is more than one observation of some plant phenophases at ",
            sitecap, " in a day")
  }
  
  # Calculate the interval between observations of the plant, phenophase
  si <- si %>%
    arrange(common_name, individual_id, phenophase_description, yr, day_of_year)
  
  si$interval_raw <- c(NA, si$day_of_year[2:nrow(si)] - si$day_of_year[1:(nrow(si) - 1)])
  same_ind <- 1 * (si$individual_id[2:nrow(si)] == si$individual_id[1:(nrow(si) - 1)])
  same_php <- 1 * (si$phenophase_id[2:nrow(si)] == si$phenophase_id[1:(nrow(si) - 1)])
  same_yr <- 1 * (si$yr[2:nrow(si)] == si$yr[1:(nrow(si) - 1)])
  si$same_ind <- c(NA, same_ind)
  si$same_php <- c(NA, same_php)
  si$same_yr <- c(NA, same_yr)
  si <- si %>%
    mutate(interval = case_when(
      same_ind == 0 ~ NA,
      same_php == 0 ~ NA,
      same_yr == 0 ~ NA,
      is.na(interval_raw) ~ NA,
      .default = interval_raw
    )) %>%
    select(-c(interval_raw, same_ind, same_php, same_yr))

  assign(paste0("si_", site), si)
}

# Create intensity dataset combined for all sites
si_files <- ls()[ls() %in% paste0("si_", sites)]
si <- do.call(rbind, mget(si_files))
rownames(si) <- NULL
rm(list = si_files)

# Add short site name
si <- si %>%
  mutate(site = str_to_lower(str_sub(site_name, 1, 4))) %>%
  mutate(site = str_replace_all(site, "home", "ellen"))

# Summarize amount and quality of information for each plant, phenophase, year
pl_ph_yr <- si %>%
  group_by(site, common_name, individual_id, phenophase_description, yr) %>%
  summarize(nobs = n(),
            first_obs = min(day_of_year),
            last_obs = max(day_of_year),
            mean_int = round(mean(interval, na.rm = TRUE), 2),
            max_int = ifelse(nobs ==1, NA, max(interval, na.rm = TRUE)),
            n_inphase = sum(phenophase_status),
            n_intvalue = sum(!is.na(intensity_value)),
            prop_inphase = round(n_inphase / nobs, 2),
            prop_intvalue = round(n_intvalue / n_inphase, 2),
            .groups = "keep") %>%
  data.frame()

# For exploring intensity data, we will filter the data:
  # remove plant-php-year combos with no observations in phase
  # remove plant-php-year combos with no observations with intensity values
  # remove plant-php-year combos with < 5 observations
  # remove plant-php-year combos when max interval > 14 days
    # (using 14-day max interval cutoff rather than mean interval mostly removes
    # no. years for Ellen's plants; most now 3-4 years)

# Side note: Checked that individual_id's for plants at NEON sites weren't 
# changing annually like the site_id's do. Luckily, that doesn't seem to be the 
# case, as most plants are monitored for multiple years.

pl_ph_yr <- pl_ph_yr %>%
mutate(remove = case_when(
  n_inphase == 0 ~ 1,
  n_intvalue == 0 ~ 1,
  nobs < 5 ~ 1,
  # mean_int > 14 ~ 1,
  max_int > 14 ~ 1,
  .default = 0
))
si <- si %>%
  left_join(select(pl_ph_yr, individual_id, phenophase_description, yr, remove),
            by = c("individual_id", "phenophase_description", "yr")) %>%
  filter(remove == 0) %>%
  select(-remove)

# Check that there's only one intensity category for each species-phenophase?
  spil <- si %>%
    filter(!is.na(intensity_category_id)) %>%
    distinct(common_name, phenophase_description, intensity_name, 
             intensity_type, intensity_label)
  spl <- si %>%
    distinct(common_name, phenophase_description)
  # setdiff(spl, spil[, 1:2])

# Make intensity midpoints = 0 if status = 0 and add intensity category labels
si <- si %>%
  mutate(intensity_midpoint = ifelse(phenophase_status == 0, 
                                     0, intensity_midpoint)) %>%
  select(-c(intensity_name, intensity_type, intensity_label)) %>%
  left_join(spil, by = c("common_name", "phenophase_description"))
```

```{r summarize-data}

# Site-species summaries
site_spp <- si %>%
  mutate(php_type = case_when(
    class_id %in% leaf_classes ~ "Leaves",
    class_id %in% flower_classes ~ "Flowers",
    class_id %in% fruit_classes ~ "Fruit"
  )) %>%
  group_by(site, common_name, species_functional_type) %>%
  summarize(n_plants = n_distinct(individual_id),
            first_yr = min(yr),
            last_yr = max(yr),
            n_yrs = n_distinct(yr),
            n_php = n_distinct(phenophase_id),
            leaf_php = n_distinct(phenophase_id[php_type == "Leaves"]),
            flower_php = n_distinct(phenophase_id[php_type == "Flowers"]),
            fruit_php = n_distinct(phenophase_id[php_type == "Fruit"]),
            .groups = "keep") %>%
  arrange(site, species_functional_type, desc(n_plants), desc(n_yrs),
          desc(n_php)) %>%
  data.frame()

# Identify which species to focus on at Ellen's site: 1/2 species per functional
# type, prioritizing no. plants, no. years, and then no. phenophases
site_spp <- site_spp %>%
  group_by(site, species_functional_type) %>%
  mutate(priority = row_number()) %>%
  # Keep all species that have at least 3 plants
  mutate(priority = ifelse(n_plants > 2, 1, priority)) %>%
  data.frame()

# Remove any species that are lower priority
si <- si %>%
  left_join(select(site_spp, site, common_name, priority),
            by = c("site", "common_name")) %>%
  filter(priority == 1) %>%
  select(-priority)
site_spp <- site_spp %>%
  filter(priority == 1) %>%
  select(-priority)
  
# Site-species-phenophase summary
site_spp_ph <- si %>%
  group_by(site, common_name, phenophase_description) %>%
  summarize(n_plants = n_distinct(individual_id),
            first_yr = min(yr),
            last_yr = max(yr),
            n_yrs = n_distinct(yr),
            n_obs = n(),
            mean_int = round(mean(interval, na.rm = TRUE), 2),
            max_int = max(interval, na.rm = TRUE),
            .groups = "keep") %>%
  mutate(obs_per_yr = round(n_obs / n_yrs, 1)) %>%
  relocate(obs_per_yr, .after = "n_obs") %>%
  data.frame()
```

```{r}
#| label: site-spp
#| tbl-cap: Amount of filtered data available for each species at each site.

site_spp_t <- site_spp %>%
  mutate(site = str_to_upper(site),
         yr_range = paste(first_yr, "-", last_yr),
         phps = paste0(n_php, " (", leaf_php, ",", flower_php, 
                       ",", fruit_php, ")")) %>%
  relocate(yr_range, .before = "n_yrs") %>%
  select(-c(first_yr, last_yr, n_php, leaf_php, flower_php, fruit_php)) %>%
  kbl(col.names = c("Site", "Species", "Functional group", "No. plants",
                    "Year range", "No. years", "No. phenophases (leaf, flower, fruit)"),
      align = c(rep("r", 3), rep("c", 4))) %>%
  kable_styling(full_width = FALSE, font_size = 11)
site_spp_t
```

```{r exclude-some-intensity-cats}

# Create table summarizing amount of information per intensity category
intensity_cats <- si %>%
  group_by(class_id, intensity_label, intensity_type) %>%
  summarize(n = n(),
            n_spp = n_distinct(common_name),
            n_plants = n_distinct(individual_id),
            n_yrs = n_distinct(yr),
            values = paste(sort(unique(intensity_midpoint)), collapse = ", "),
            .groups = "keep") %>%
  data.frame()

# Identify categories that we want to exclude because:
  # Only one intensity value represented in dataset
  # Fewer than 50 observations across species, plants, and years
intensity_cats <- intensity_cats %>%
  mutate(exclude = case_when(
    str_detect(values, ", ", negate = TRUE) ~ 1, 
    n < 50 ~ 1, 
    .default = 0
  ))

# Remove categories from dataset and intensity category table
si <- si %>%
  left_join(select(intensity_cats, intensity_label, exclude), 
            by = "intensity_label") %>%
  filter(exclude == 0) %>%
  select(-exclude)
intensity_cats <- intensity_cats %>%
  filter(exclude == 0) %>%
  select(-exclude)

# Summarize data available for each plant, phenophase, and year (in part
# to figure out what data to include in GAMs). Recreating pl_ph_yr...
  # Going to use rle(phenophase_status) to understand the patterns:
    # length(rle$values) = number of 0/1 status sequences
    # first(rle$values) = state at first observation
    # last(rle$values) = state at last observation
pl_ph_yr <- si %>%
  arrange(site, individual_id, phenophase_id, observation_date) %>%
  group_by(site, common_name, individual_id, phenophase_description,
           intensity_label, class_id, yr) %>%
  summarize(nobs = n(),
            first_obs = min(day_of_year),
            last_obs = max(day_of_year),
            mean_int = round(mean(interval, na.rm = TRUE), 2),
            max_int = ifelse(nobs ==1, NA, max(interval, na.rm = TRUE)),
            n_inphase = sum(phenophase_status),
            # n_intvalue = sum(!is.na(intensity_value)),
            prop_inphase = round(n_inphase / nobs, 2),
            # prop_intvalue = round(n_intvalue / n_inphase, 2),
            n_states = length(rle(phenophase_status)$values),
            first_status = first(rle(phenophase_status)$values),
            last_status = last(rle(phenophase_status)$values),
            .groups = "keep") %>%
  data.frame()

# Summarize across species
# pl_ph_yr %>%
#   group_by(common_name) %>%
#   summarize(n = n(),
#             n_status0 = sum(prop_inphase < 1),
#             prop_status0 = round(n_status0 / n, 2),
#             n_states_mn = round(mean(n_states), 2),
#             n_states_min = min(n_states),
#             n_states_max = max(n_states),
#             prop_start0 = round(sum(first_status == 0) / n, 2),
#             prop_end0 = round(sum(last_status == 0) / n, 2), 
#             prop_00 = round(sum(first_status == 0 & last_status == 0) / n, 2),
#             .groups = "keep") %>%
#   data.frame() %>%
#   arrange(desc(n))

# Summarize across phenophases
# pl_ph_yr %>%
#   group_by(class_id, phenophase_description, intensity_label) %>%
#   summarize(n = n(),
#             n_status0 = sum(prop_inphase < 1),
#             prop_status0 = round(n_status0 / n, 2),
#             n_states_mn = round(mean(n_states), 2),
#             n_states_min = min(n_states),
#             n_states_max = max(n_states),
#             prop_start0 = round(sum(first_status == 0) / n, 2),
#             prop_end0 = round(sum(last_status == 0) / n, 2), 
#             prop_00 = round(sum(first_status == 0 & last_status == 0) / n, 2),
#             .groups = "keep") %>%
#   data.frame()
# Simpler...
php_summary <- pl_ph_yr %>%
  group_by(class_id, phenophase_description, intensity_label) %>%
  summarize(n_plantyrs = n(),
            n_states_mn = round(mean(n_states), 2),
            n_states_max = max(n_states),
            prop_00 = round(sum(first_status == 0 & last_status == 0) / n_plantyrs, 2),
            .groups = "keep") %>%
  data.frame()

# Look more closely at some phenophases, where mean number of status series
# varies a lot from 3 (ideally 0-1-0) and the proportion of plant-php-yrs
# that start and end out of phase is << 1
intensities <- php_summary %>%
  filter(prop_00 < 0.70) %>%
  pull(intensity_label)
# Young leaves (tree/shrub) - no.
# Leaves - canopy fullness (%)
# Leaves (sedges) - greeness (%)
# Colored leaves - canopy color (%)
# Fruits - no.
# Ripe fruits (%)

# Look at these intensity curves in turn
# intens <- intensities[6]
#   
#   si_int <- filter(si, intensity_label == intens)
#   spps <- unique(si_int$common_name)
#   
#   # Remove observations where phenophase status is 1, but intensity value wasn't 
#   # provided (this creates breaks in plotted lines)
#   si_int <- filter(si_int, !is.na(intensity_midpoint))
#   
#   # Plot logged values for numeric intensity categories
#   if (si_int$intensity_type[1] == "number") {
#     si_int <- si_int %>%
#       mutate(yaxis = intensity_midpoint_log)
#   } else {
#     si_int <- si_int %>%
#       mutate(yaxis = intensity_midpoint)
#   }
# 
#   for (spp in spps) {
#   
#     si_int_spp <- filter(si_int, common_name == spp)
# 
#     ylab <- ifelse(si_int$intensity_type[1] == "number",
#                    paste0("log(", str_to_lower(si_int$intensity_label[1]), ")"),
#                    si_int$intensity_label[1])
#     
#     ics <- ggplot(si_int_spp, aes(x = day_of_year, y = yaxis)) +
#       geom_line(aes(color = factor(individual_id))) +
#       facet_grid(yr ~ .) +
#       theme(legend.position = "none") +
#       labs(title = paste0(str_to_sentence(spp), ",  ", intens),
#            y = ylab, x = "Day of year")
#     
#     print(ics)
#   }
  
# Young leaves - no.
  # velvet mesquite: 2016 didn't start till late, but other years look good with multiple humps
  # desert zinnia: good, just often 1-1 to start/end; lots more plants in 2017-2019.
  # creosote bush: 2016 didn't start till late, doesn't always have 0-0 to start-end
  # mountain laurel: good
  
# Leaves - % canopy fullness
  # velvet mesquite: good, but not 2016
  # desert zinnia: good
  # sugar maple: good
  # forsythia: good
  # dwarf birch: 2016 and 2020 started late, but other years look good
  # quaking aspen: 2017 and 2020 started late, but other years look good

# Leaves (sedges) - % greenness
  # Pennsylvania sedge: look good, just always has some green leaves
  
# Colored leaves - % canopy color 
  # velvet mesquite: 2016 started late, otherwise ok. Always low %, and often not 0-0 start-end
  # desert zinnia: 2016 started late, otherwise ok. Usually low % and often not 0-0 start-end
  # sugar maple: good
  # forsythia: good
  # dwarf birch: 2016 late start (2020 did too, but didn't matter for this phenophase)
  # quaking aspen: good. late start in 2017 and 2020 never mattered. 
  
# Fruits - no. ##### most questionable #####
  # velvet mesquite: 1 plant, 1 year so no help.
  # creosote bush: 6 plants & 1 year. Not sure these curves are helpful ########
  # sugar maple: 2 plants, 3 years. ok
  # mountain laurel: 1 plant, 3 years. Not sure these curves are helpful since
    # 2 end year with fruits and aren't monitored for long time after
  # Virginia strawberry: 1 plant, 3 years. good
  
# Ripe fruit % ##### most questionable #####
  # creosote bush: 6 plants, 1 year. Not sure it's helpful, ends at 1 but starts late at 0
  # sugar maple: 2 plants, 2 years. ok
  # mountain laurel: 1 plant, 1 year, ends at 1. no help
  # Virginia strawberry: 1 plant, 1 year so no help
  # Pennsylvania sedge: 1 plant, 3 years. good ##### exception?

# UPSHOT: 
# So maybe exclude the fruit phenophases for now?  Very little data to go on and 
# the patterns are more difficult to parse out
  
# NEON sites had some years where monitoring started late (but note that this 
# may not matter for phenophases that occur later in the year)
  # BONA [quaking aspen]: 2017 and 2020 
  # DEJU [dwarf birch]: 2016 and 2020
  # SRER [velvet mesquite, creosote bush, desert zinnia]: 2016
  
si <- si %>%
  filter(!(site == "bona" & yr %in% c(2017, 2020))) %>%
  filter(!(site == "deju" & yr %in% c(2016, 2020))) %>%
  filter(!(site == "srer" & yr == 2016))
 
# Use a rule to exclude any species-phenophase combination where there's only one 
# plant-year of data (in case there are any beyond those in the fruit categories)
si <- si %>%
  group_by(common_name, phenophase_description) %>%
  mutate(n_plants = n_distinct(individual_id),
         n_yrs = n_distinct(yr)) %>%
  ungroup() %>%
  filter(n_plants * n_yrs > 1) %>%
  select(-c(n_plants, n_yrs)) %>%
  data.frame()
```

```{r}
#| label: php-summary
#| tbl-cap: Summary of data available for each phenophase and intensity category. 

php_summary_t <- php_summary %>%
  mutate(n_transitions_mn = n_states_mn - 1,
         n_transitions_max = n_states_max - 1) %>%
  select(-c(class_id, n_states_mn, n_states_max)) %>%
  relocate(prop_00, .after = "n_transitions_max") %>%
  kbl(col.names = c("Phenophase", "Intensity category", "No. plant-years", 
                    "Mean no. status transitions per yr", 
                    "Max. no. status transitions per yr", 
                    "Prop. of plant-years that start and end out of phase"),
      align = c(rep("r", 2), rep("c", 4))) %>%
  kable_styling(full_width = FALSE, font_size = 11)
php_summary_t
```

## Using GAMs to describe seasonal changes in phenophase intensity

We wanted to model how phenophase intensity changes over the course of a season for various plant species and phenophases. Given that patterns are often more complex that that described by a simple linear or quadratic model, we used generaled additive models (GAMs) for this task.

One challenge in modeling these data is that intensity values (or intensity category midpoints) are not normally distributed. For numeric intensity categories (e.g., the number of breaking leaf buds or flowers), values can range from 0 (when the plant is not in the associated phenophase) to \>10,000, and the midpoints are not evenually distributed across that range. For example, the observed number of flowers on a plant can take one of the following values: 0, 1, 5, 50, 500, 5000, or 10,000. For percentage intensity categories (e.g., leaf canopy fullness or the % of flowers that are open), values are bounded by 0 and 100, or 0 and 1 if converted to proportions.

We used the `mgcv` package in R to contruct GAM models. While the `gam()` function in this package allows the user to specifiy a non-Gaussian distribution and link function when fitting a model, alternative distributions were not suitable given the structure of our data. A Poisson distribution did not provide a good fit for our numeric data because non-zero values were infrequent and took only a few unique values that differed by orders of magnitude. A beta distribution with a logit link did not provide a good fit for our proportional data because we had an abundance of zero values, which are not compatible with the beta distribution (support on (0,1) and not \[0,1\]). To fit a beta distribution, we were required to "nudge" values slightly above zero, which caused significant biases in predicted values (see <https://www.robertkubinec.com/post/limited_dvs/>). Given these obstacles, we elected to transform intensity values prior to fitting a model, which enabled us to use Gaussian distributions in GAMs. Specifically, for numeric intensity values, we added a small amount (0.01) to zero values and log-transformed the data; for percentage intensity values, we added a small amount (0.01) to zero values, divided by 100, and logit-transformed the data. For reporting and visualizations, we backtransformed predicted values to the original scale for easier interpretation.

```{r GAMs}
#| eval: false

# Helpful GAM references:
# https://fromthebottomoftheheap.net/2014/05/09/modelling-seasonal-data-with-gam
# https://m-clark.github.io/generalized-additive-models/
# https://stats.stackexchange.com/questions/552880/by-group-random-effect-gam
# Canizares et al. 2023 (example with cc smooths)

# Remove phenophases/intensity categories that we won't explore (at least right away)
gamdf <- si %>%
  filter(!phenophase_description %in% c("Fruits", "Ripe fruits")) %>%
  arrange(class_id, phenophase_description, site, common_name, individual_id, 
          observation_date) %>%
  # Remove any observations with missing intensity values
  filter(!is.na(intensity_midpoint))

# Transform intensity data (numeric/percentage separately then merge back together)
numeric_no0 <- 0.01
percentage_no0 <- 0.01
gamdf_n <- gamdf %>%
  filter(intensity_type == "number") %>%
  mutate(intensity_midpoint_no0 = case_when(
    intensity_midpoint == 0 ~ numeric_no0,
    intensity_midpoint != 0 ~ intensity_midpoint
  )) %>%
  mutate(intensity_t = log(intensity_midpoint_no0))
gamdf_p <- gamdf %>%
  filter(intensity_type == "percent") %>%
  mutate(intensity_midpoint_no0 = case_when(
    intensity_midpoint == 0 ~ percentage_no0,
    intensity_midpoint != 0 ~ intensity_midpoint
  )) %>%
  mutate(intensity_midpoint_no0 = intensity_midpoint_no0 / 100) %>%
  mutate(intensity_t = log(intensity_midpoint_no0 / (1 - intensity_midpoint_no0)))
gamdf <- rbind(gamdf_n, gamdf_p)
# check:
# count(gamdf, intensity_type, intensity_midpoint, intensity_midpoint_no0, intensity_t)

# List of species-intensity category combianations
combos <- gamdf %>%
  group_by(intensity_label, intensity_type, common_name) %>%
  summarize(n_plants = n_distinct(individual_id),
            n_yrs = n_distinct(yr),
            .groups = "keep") %>%
  data.frame()




# TODO: accomodate combos with 1 year or 1 plants...

# Set up table to hold results (and save images with logical names)
# combos columns, no. plant-years, model (one smooth, annual smooths), deviance explained, GCV,
# predicted peak, quantiles...

# Loop through species/intensities, fitting GAMs, ....

# for (i in 1:nrow(combos)) {
i = 1
intdf <- gamdf %>%
  filter(intensity_label == combos$intensity_label[i],
         common_name == combos$common_name[i])

intdf$individual_id <- factor(intdf$individual_id)
intdf$fyr <- factor(intdf$yr)
# intdf$indyr <- factor(paste0(intdf$individual_id, "_", intdf$yr))

# Logical indicating whether to use a cyclic smooth (when observation date
# range starts in first two weeks of the year and ends in the last two weeks)
cubic_bs <- ifelse(min(intdf$day_of_year) <= 14 & max(intdf$day_of_year >= (365 - 14)),
                   "cc", "cr")

# Fit same smooth each year, random intercepts for individual plants without 
# any accounting for year (and many plants monitored in multiple years)
  # m0 <- gam(resp ~ s(day_of_year, bs = "cc", k = 20) +  s(individual_id, bs = "re"),
  #           method = "REML", data = intdf)
  # summary(m0)
# I'm not sure this is valid given that we're interested in plant-specific
# annual curves. If year isn't in the model anywhere then we're creating one
# curve for each plant by combining data across years, which seems wrong.

# Fit same smooth each year, with random intercepts for each plant-year combo
m1 <- gam(resp ~ s(day_of_year, bs = cubic_bs, k = 20) +  
            s(individual_id, fyr, bs = "re"),
          method = "REML", data = intdf)
summary(m1)

  # Get names of smooth terms
  sapply(m1$smooth, "[[", "label")
  #  "s(day_of_year)"       "s(individual_id,fyr)" 

  # Make predictions using mgcv::predict.gam()
  # see: https://stackoverflow.com/questions/51634953/gam-with-gp-smoother-predict-at-new-locations/51635487#51635487
  m1_new <- data.frame(day_of_year = min(intdf$day_of_year):max(intdf$day_of_year),
                       individual_id = intdf$individual_id[1], 
                       fyr = 2018) # checked that I can feed any values here (but get warning if not in orig dataset)
  m1_p <- predict(m1, newdata = m1_new, type = "terms", 
                  terms = "s(day_of_year)", se.fit = TRUE)
  
  # Simplify to dataframe and calculate CI
  m1_preds <- data.frame(day_of_year = m1_new$day_of_year,
                         fit = attr(m1_p, "constant") + rowSums(m1_p$fit),
                         se.fit = rowSums(m1_p$se.fit)) %>%
    mutate(lcl = fit - 1.96 * se.fit,
           ucl = fit + 1.96 * se.fit)

  # Create ggplot object with y axis back on original scale
  desired_y_breaks <- c(0.1, 1, 5, 50, 500, 5000, 10000)
  y_labels_log <- log(desired_y_breaks)
  desired_y_labels <- c(0, 1, 5, 50, 500, 5000, 10000)
  
  m1_plot <- ggplot() +
    geom_point(data = intdf, aes(x = day_of_year, y = resp), shape = 19, color = "gray") +
    # geom_ribbon(data = m1_preds, aes(x = day_of_year, ymin = lcl, ymax = ucl), 
    #             fill = "#a1d99b", alpha = 0.5) +
    geom_line(data = m1_preds, aes(x = day_of_year, y = fit)) +
    labs(x = "Day of year", 
         y = combos[i, 1],
         title = paste0(intdf$intensity_label[1], ", ", intdf$common_name[1], 
                        " (", length(unique(intdf$individual_id)), " plants; ", 
                        length(unique(intdf$yr)), " years)")) +
    scale_y_continuous(breaks = y_labels_log,
                       labels = desired_y_labels) +
    theme_bw()
  m1_plot  

  # Using marginaleffects package to get predictions
  m1_preds_me <- predictions(m1,
                  newdata = data.frame(
                    day_of_year = min(intdf$day_of_year):max(intdf$day_of_year),
                    individual_id = intdf$individual_id[500],
                    fyr = 2021),
                  exclude = "s(individual_id,fyr)") 
  # Confirmed that I can change individual_id and fyr and get same results
  # Confirmed that results are almost identical to that from predict.gam (CIs 
  # slightly different)

# Fit different smooths each year (fixed effects), with random intercepts for 
# individual plants.
m2 <- gam(resp ~ fyr + 
            s(day_of_year, by = fyr, bs = cubic_bs, k = 20) +
            s(individual_id, bs = "re"),
          method = "REML", data = intdf)
summary(m2)

  # Get names of smooth terms
  (m2_terms <- sapply(m2$smooth, "[[", "label"))
  #  "s(day_of_year):fyr2018" "s(day_of_year):fyr2019" "s(day_of_year):fyr2021" 
  #  "s(day_of_year):fyr2022" "s(individual_id)"   

  # Make predictions using mgcv::predict.gam()
  # Create a dataframe to hold predictions from more complex model
  for (yr in sort(unique(intdf$yr))) {
    min_doy <- min(intdf$day_of_year[intdf$fyr == yr])
    max_doy <- max(intdf$day_of_year[intdf$fyr == yr])
    doys <- seq(min_doy, max_doy)
    if (yr == min(intdf$yr)) {
      m2_new <- data.frame(fyr = yr, day_of_year = doys)
    } else {
      m2_new <- rbind(m2_new, data.frame(fyr = yr, day_of_year = doys))
    }
  }
  m2_new$individual_id <- intdf$individual_id[1]
  
  m2_p <- predict(m2, newdata = m2_new, type = "terms", 
                  exclude = m2_terms[length(m2_terms)], se.fit = TRUE)
  
  # Simplify to dataframe and calculate CI
  m2_preds <- data.frame(fyr = m2_new$fyr,
                         day_of_year = m2_new$day_of_year,
                         fit = attr(m2_p, "constant") + rowSums(m2_p$fit),
                         se.fit = rowSums(m2_p$se.fit)) %>%
    mutate(lcl = fit - 1.96 * se.fit,
           ucl = fit + 1.96 * se.fit)
  m2_preds$fyr <- factor(m2_preds$fyr)

  # Create ggplot object
  m2_plot <- ggplot(data = m2_preds,
                    aes(x = day_of_year, group = fyr, color = fyr, fill = fyr)) +
    geom_point(data = intdf, aes(x = day_of_year, y = resp, group = NULL), 
               shape = 19, color = "gray", show.legend = FALSE) +
    # geom_ribbon(data = m2_preds, aes(ymin = lcl, ymax = ucl), 
    #             linewidth = 0, alpha = 0.3) +
    geom_line(data = m2_preds, aes(x = day_of_year, y = fit, group = fyr)) +
    labs(x = "Day of year", 
         y = paste0("log(", combos[i, 1], ")"),
         title = paste0(intdf$intensity_label[1], ", ", intdf$common_name[1], 
                        " (", length(unique(intdf$individual_id)), " plants; ", 
                        length(unique(intdf$yr)), " years)"),
         # fill = "Year",
         color = "Year") +
    theme_bw()
  m2_plot  

  # Using marginaleffects package to get predictions
  m2_preds_me <- predictions(m2, newdata = m2_new, exclude = "s(individual_id)") 
  # CI are somewhat narrower here than when I calculated them using predict.gam


# Compare AIC values
AIC(m1, m2)

# Fit individual smooths for each year and plant? Hangs up indefinitely....
# https://stackoverflow.com/questions/68659805/mgcv-gam-more-than-one-variable-in-by-argument-smooth-varying-by-more-than-1
  # m3 <- gam(intensity_midpoint_log ~ fyr + individual_id +
  #             s(day_of_year, by = interaction(fyr, individual_id), bs = "cr", k = 20),
  #           method = "REML", data = intdf)
  # summary(m3)

# Looking at intensity data that are proportions/percentages
i = 34 # open flowers, dwarf birch (24 plants, 4 years)
intdf <- gamdf %>%
  filter(intensity_label == combos$intensity_label[i],
         common_name == combos$common_name[i])

intdf$individual_id <- factor(intdf$individual_id)
intdf$fyr <- factor(intdf$yr)

# Logical indicating whether to use a cyclic smooth (when observation date
# range starts in first two weeks of the year and ends in the last two weeks)
cubic_bs <- ifelse(min(intdf$day_of_year) <= 14 & max(intdf$day_of_year >= (365 - 14)),
                   "cc", "cr")

# Fit same smooth each year, with random intercepts for each plant-year combo.
# Specifying a beta regression to deal with data in (0, 1)
intdf$resp <- intdf$resp / 100
m1 <- gam(resp ~ s(day_of_year, bs = cubic_bs, k = 20) +  
            s(individual_id, fyr, bs = "re"),
          method = "REML", family = betar(link = "logit"), data = intdf)
summary(m1)

  # Get names of smooth terms
  sapply(m1$smooth, "[[", "label")
  #  "s(day_of_year)"       "s(individual_id,fyr)" 

  # Make predictions using mgcv::predict.gam()
  m1_new <- data.frame(day_of_year = min(intdf$day_of_year):max(intdf$day_of_year),
                       individual_id = intdf$individual_id[1], 
                       fyr = intdf$fyr[1])
  m1_p <- predict(m1, newdata = m1_new, type = "terms", 
                  terms = "s(day_of_year)", se.fit = TRUE)
  
  # Simplify to dataframe and calculate CI
  m1_preds <- data.frame(day_of_year = m1_new$day_of_year,
                         fitl = attr(m1_p, "constant") + rowSums(m1_p$fit),
                         se.fit = rowSums(m1_p$se.fit)) %>%
    mutate(fit = exp(fitl) / (1 + exp(fitl)),
           lcll = fitl - 1.96 * se.fit,
           ucll = fitl + 1.96 * se.fit,
           lcl = exp(lcll) / (1 + exp(lcll)),
           ucl = exp(ucll) / (1 + exp(ucll)))

  # Create ggplot object
  m1_plot <- ggplot() +
    geom_point(data = intdf, aes(x = day_of_year, y = resp), shape = 19, color = "gray") +
    geom_ribbon(data = m1_preds, aes(x = day_of_year, ymin = lcl, ymax = ucl), 
                fill = "#a1d99b", alpha = 0.5) +
    geom_line(data = m1_preds, aes(x = day_of_year, y = fit)) +
    labs(x = "Day of year", 
         y = combos[i, 1],
         title = paste0(intdf$intensity_label[1], ", ", intdf$common_name[1], 
                        " (", length(unique(intdf$individual_id)), " plants; ", 
                        length(unique(intdf$yr)), " years)")) +
    theme_bw()
  m1_plot  

  # Using marginaleffects package to get predictions
  m1_preds_me <- predictions(m1,
                  newdata = data.frame(
                    day_of_year = min(intdf$day_of_year):max(intdf$day_of_year),
                    individual_id = intdf$individual_id[500],
                    fyr = 2020),
                  type = "response",
                  exclude = "s(individual_id,fyr)") 

  # Get equivalent predictions from both methods, but the predictions seem off -
  # they don't approach the bounds/0, even though they definitely should. 
  # Trying a model where I tranform proportional data to real scale first
  
  intdf$resp <- ifelse(intdf$intensity_midpoint == 0,
                       0.001, intdf$intensity_midpoint)
  intdf$resp <- intdf$resp / 100
  intdf$respR <- log(intdf$resp / (1 - intdf$resp))
  
  m1trans <- gam(respR ~ s(day_of_year, bs = cubic_bs, k = 20) +  
                 s(individual_id, fyr, bs = "re"),
          method = "REML", data = intdf)
  summary(m1trans)

  m1_p <- predict(m1trans, newdata = m1_new, type = "terms", 
                  terms = "s(day_of_year)", se.fit = TRUE)
  
  # Simplify to dataframe and calculate CI
  m1_preds <- data.frame(day_of_year = m1_new$day_of_year,
                         fitl = attr(m1_p, "constant") + rowSums(m1_p$fit),
                         se.fit = rowSums(m1_p$se.fit)) %>%
    mutate(fit = exp(fitl) / (1 + exp(fitl)),
           lcll = fitl - 1.96 * se.fit,
           ucll = fitl + 1.96 * se.fit,
           lcl = exp(lcll) / (1 + exp(lcll)),
           ucl = exp(ucll) / (1 + exp(ucll)))

  # Create ggplot object
  m1_plot <- ggplot() +
    geom_point(data = intdf, aes(x = day_of_year, y = resp), shape = 19, color = "gray") +
    geom_ribbon(data = m1_preds, aes(x = day_of_year, ymin = lcl, ymax = ucl), 
                fill = "#a1d99b", alpha = 0.5) +
    geom_line(data = m1_preds, aes(x = day_of_year, y = fit)) +
    labs(x = "Day of year", 
         y = combos[i, 1],
         title = paste0(intdf$intensity_label[1], ", ", intdf$common_name[1], 
                        " (", length(unique(intdf$individual_id)), " plants; ", 
                        length(unique(intdf$yr)), " years)")) +
    theme_bw()
  m1_plot  
  # This is much more like what I expected, with the caveat that there is
  # essentially no uncertainty around the curve once it gets close to 0
  
  m1_preds_me <- predictions(m1trans,
                  newdata = data.frame(
                  day_of_year = min(intdf$day_of_year):max(intdf$day_of_year),
                    individual_id = intdf$individual_id[500],
                    fyr = 2020),
                  exclude = "s(individual_id,fyr)") 
  m1_preds_me2 <- as.data.frame(m1_preds_me) %>%
    mutate(estimateP = exp(estimate) / (1 + exp(estimate)),
           conf.lowP = exp(conf.low) / (1 + exp(conf.low)),
           conf.highP = exp(conf.high) / (1 + exp(conf.high)))
  # Same
  
# Fit different smooths each year (fixed effects), with random intercepts for 
# individual plants.
m2trans <- gam(respR ~ fyr + 
               s(day_of_year, by = fyr, bs = cubic_bs, k = 20) +
               s(individual_id, bs = "re"),
          method = "REML", data = intdf)
summary(m2trans)

  # Get names of smooth terms
  (m2_terms <- sapply(m2trans$smooth, "[[", "label"))
  #  "s(day_of_year):fyr2018" "s(day_of_year):fyr2019" "s(day_of_year):fyr2021" 
  #  "s(day_of_year):fyr2022" "s(individual_id)"   

  # Make predictions using mgcv::predict.gam()
  # Create a dataframe to hold predictions from more complex model
  for (yr in sort(unique(intdf$yr))) {
    min_doy <- min(intdf$day_of_year[intdf$fyr == yr])
    max_doy <- max(intdf$day_of_year[intdf$fyr == yr])
    doys <- seq(min_doy, max_doy)
    if (yr == min(intdf$yr)) {
      m2_new <- data.frame(fyr = yr, day_of_year = doys)
    } else {
      m2_new <- rbind(m2_new, data.frame(fyr = yr, day_of_year = doys))
    }
  }
  m2_new$individual_id <- intdf$individual_id[1]
  
  m2_p <- predict(m2trans, newdata = m2_new, type = "terms", 
                  exclude = m2_terms[length(m2_terms)], se.fit = TRUE)
  
  # Simplify to dataframe and calculate CI
  m2_preds <- data.frame(fyr = m2_new$fyr,
                         day_of_year = m2_new$day_of_year,
                         fitl = attr(m2_p, "constant") + rowSums(m2_p$fit),
                         se.fit = rowSums(m2_p$se.fit)) %>%
    mutate(fit = exp(fitl) / (1 + exp(fitl)),
           lcll = fitl - 1.96 * se.fit,
           ucll = fitl + 1.96 * se.fit,
           lcl = exp(lcll) / (1 + exp(lcll)),
           ucl = exp(ucll) / (1 + exp(ucll)))
  m2_preds$fyr <- factor(m2_preds$fyr)

  # Create ggplot object
  m2_plot <- ggplot(data = m2_preds,
                    aes(x = day_of_year, group = fyr, color = fyr, fill = fyr)) +
    geom_point(data = intdf, aes(x = day_of_year, y = resp, group = NULL), 
               shape = 19, color = "gray", show.legend = FALSE) +
    # geom_ribbon(data = m2_preds, aes(ymin = lcl, ymax = ucl),
    #             linewidth = 0, alpha = 0.3) +
    geom_line(data = m2_preds, aes(x = day_of_year, y = fit, group = fyr)) +
    labs(x = "Day of year", 
         y = combos[i, 1],
         title = paste0(intdf$intensity_label[1], ", ", intdf$common_name[1], 
                        " (", length(unique(intdf$individual_id)), " plants; ", 
                        length(unique(intdf$yr)), " years)"),
         # fill = "Year",
         color = "Year") +
    theme_bw()
  m2_plot  

  # Using marginaleffects package to get predictions
  m2_preds_me <- predictions(m2trans, newdata = m2_new, exclude = "s(individual_id)") 
  m2_preds_me2 <- as.data.frame(m2_preds_me) %>%
    mutate(estimateP = exp(estimate) / (1 + exp(estimate)),
           conf.lowP = exp(conf.low) / (1 + exp(conf.low)),
           conf.highP = exp(conf.high) / (1 + exp(conf.high)))



# }



```

```{r status-intensity-curves}


```

```{r derived-metrics}


```
