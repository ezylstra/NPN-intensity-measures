---
title: "Exploration of intensity data"
date: "`r format(Sys.time(), '%d %B, %Y')`"
author: "Erin Zylstra"
execute: 
  echo: false
  error: false
  warning: false
  message: false
format: 
  html:
    fig-cap-location: top
    page-layout: full
editor: visual
editor_options: 
  chunk_output_type: console
---

```{r}

library(dplyr)
library(stringr)
library(lubridate)
library(ggplot2)
library(cowplot)
library(kableExtra)
library(mgcv)
# library(brms)
library(marginaleffects)
library(gratia)
library(glmmTMB)
```

## Overview

To evaluate intensity data, we extracted observations of plants from Ellen Denny's site, and three NEON sites. At Ellen's site, we used observations of multiple plant species that comprise functional types. At BONA (NEON; AK) we're using observations of quaking aspen, at DEJU (NEON; AK) we're using obervations of dwarf birch, and at SRER (NEON; AZ) we're using observations of desert zinnia, velvet mesquite, and creosote bush.

We filtered the data by removing plant-year-phenophase combinations when:

-   there were no observations in phase (status always recorded as "no")
-   there were no observations with intensity values (rarely happened with plants in phase in these datasets)
-   there were fewer than 5 observations
-   the maximum interval between consecutive observations \> 14 days
-   the first observation occurred after the onset of most phenophases (2017 and 2020 at BONA; 2016 and 2020 at DEJU; and 2016 at SRER)

Other filtering steps:

-   excluded any species-phenophase combinations that were only represented by a single plant in a single year.
-   excluded intensity categories that were represented by only 1-2 intensity values
-   exluded intensity categories that had fewer than 50 observations across species, plants, and years

Intensities are reported in value ranges (e.g., 3-10 flowers; 25-49% open flowers). For analysis, we represented each intensity value by the approximate midpoint of the reported range (e.g., 5 flowers, 37% open flowers, respectively).

```{r setup}

# List of sites
sites <- c("bona", "deju", "srer", "ellen")

# Plant phenophase classes
leaf_classes <- 1:5
flower_classes <- 6:9
fruit_classes <- 10:13

# List files with formatted intensity data
intensity_files <- list.files("npn-data",
                              pattern = "intensity-site",
                              full.names = TRUE)
```

```{r load-filter-data}

# Summarize data available by species, individual, phenophase
for (site in sites) {
  
  sitecap <- str_to_upper(site)
  filename <- intensity_files[grepl(sitecap, intensity_files)]
  si <- read.csv(filename)

  # Remove any true duplicates
  si <- si[!duplicated(si),]
  
  # Occasionally there are two records for a plant-phenophase in one day with 
  # different intensity or status values. Removing these observations too (not
  # trying to resolve conflicts, just deleting all observations).
  si <- si %>%
    group_by(individual_id, phenophase_id, observation_date) %>%
    mutate(n_obs = n()) %>%
    ungroup() %>%
    filter(n_obs == 1) %>%
    select(-n_obs) %>%
    data.frame()
  
  # Doublecheck that there's only one observation of each plant-phenophase per day
  if (nrow(si) != nrow(distinct(si, individual_id, phenophase_id, observation_date))) {
    warning("There is more than one observation of some plant phenophases at ",
            sitecap, " in a day")
  }
  
  # Calculate the interval between observations of the plant, phenophase
  si <- si %>%
    arrange(common_name, individual_id, phenophase_description, yr, day_of_year)
  
  si$interval_raw <- c(NA, si$day_of_year[2:nrow(si)] - si$day_of_year[1:(nrow(si) - 1)])
  same_ind <- 1 * (si$individual_id[2:nrow(si)] == si$individual_id[1:(nrow(si) - 1)])
  same_php <- 1 * (si$phenophase_id[2:nrow(si)] == si$phenophase_id[1:(nrow(si) - 1)])
  same_yr <- 1 * (si$yr[2:nrow(si)] == si$yr[1:(nrow(si) - 1)])
  si$same_ind <- c(NA, same_ind)
  si$same_php <- c(NA, same_php)
  si$same_yr <- c(NA, same_yr)
  si <- si %>%
    mutate(interval = case_when(
      same_ind == 0 ~ NA,
      same_php == 0 ~ NA,
      same_yr == 0 ~ NA,
      is.na(interval_raw) ~ NA,
      .default = interval_raw
    )) %>%
    select(-c(interval_raw, same_ind, same_php, same_yr))

  assign(paste0("si_", site), si)
}

# Create intensity dataset combined for all sites
si_files <- ls()[ls() %in% paste0("si_", sites)]
si <- do.call(rbind, mget(si_files))
rownames(si) <- NULL
rm(list = si_files)

# Add short site name
si <- si %>%
  mutate(site = str_to_lower(str_sub(site_name, 1, 4))) %>%
  mutate(site = str_replace_all(site, "home", "ellen"))

# Summarize amount and quality of information for each plant, phenophase, year
pl_ph_yr <- si %>%
  group_by(site, common_name, individual_id, phenophase_description, yr) %>%
  summarize(nobs = n(),
            first_obs = min(day_of_year),
            last_obs = max(day_of_year),
            mean_int = round(mean(interval, na.rm = TRUE), 2),
            max_int = ifelse(nobs ==1, NA, max(interval, na.rm = TRUE)),
            n_inphase = sum(phenophase_status),
            n_intvalue = sum(!is.na(intensity_value)),
            prop_inphase = round(n_inphase / nobs, 2),
            prop_intvalue = round(n_intvalue / n_inphase, 2),
            .groups = "keep") %>%
  data.frame()

# For exploring intensity data, we will filter the data:
  # remove plant-php-year combos with no observations in phase
  # remove plant-php-year combos with no observations with intensity values
  # remove plant-php-year combos with < 5 observations
  # remove plant-php-year combos when max interval > 14 days
    # (using 14-day max interval cutoff rather than mean interval doesn't remove
    # species/plants from dataset but reduces the number of years for some
    # plants at Ellen's site; most now 3-4 years)

# Side note: Checked that individual_id's for plants at NEON sites weren't 
# changing annually like the site_id's do. Luckily, that doesn't seem to be the 
# case, as most plants are monitored for multiple years.

pl_ph_yr <- pl_ph_yr %>%
mutate(remove = case_when(
  n_inphase == 0 ~ 1,
  n_intvalue == 0 ~ 1,
  nobs < 5 ~ 1,
  # mean_int > 14 ~ 1,
  max_int > 14 ~ 1,
  .default = 0
))
si <- si %>%
  left_join(select(pl_ph_yr, individual_id, phenophase_description, yr, remove),
            by = c("individual_id", "phenophase_description", "yr")) %>%
  filter(remove == 0) %>%
  select(-remove)

# Check that there's only one intensity category for each species-phenophase?
  spil <- si %>%
    filter(!is.na(intensity_category_id)) %>%
    distinct(common_name, phenophase_description, intensity_name, 
             intensity_type, intensity_label)
  spl <- si %>%
    distinct(common_name, phenophase_description)
  # setdiff(spl, spil[, 1:2])

# Make intensity midpoints = 0 if status = 0 and add intensity category labels
si <- si %>%
  mutate(intensity_midpoint = ifelse(phenophase_status == 0, 
                                     0, intensity_midpoint)) %>%
  select(-c(intensity_name, intensity_type, intensity_label)) %>%
  left_join(spil, by = c("common_name", "phenophase_description"))
```

```{r summarize-si-data}

# Site-species summaries
site_spp <- si %>%
  mutate(php_type = case_when(
    class_id %in% leaf_classes ~ "Leaves",
    class_id %in% flower_classes ~ "Flowers",
    class_id %in% fruit_classes ~ "Fruit"
  )) %>%
  group_by(site, common_name, species_functional_type) %>%
  summarize(n_plants = n_distinct(individual_id),
            first_yr = min(yr),
            last_yr = max(yr),
            n_yrs = n_distinct(yr),
            n_php = n_distinct(phenophase_id),
            leaf_php = n_distinct(phenophase_id[php_type == "Leaves"]),
            flower_php = n_distinct(phenophase_id[php_type == "Flowers"]),
            fruit_php = n_distinct(phenophase_id[php_type == "Fruit"]),
            .groups = "keep") %>%
  arrange(site, species_functional_type, desc(n_plants), desc(n_yrs),
          desc(n_php)) %>%
  data.frame()

# Identify which species to focus on at Ellen's site: 1/2 species per functional
# type, prioritizing no. plants, no. years, and then no. phenophases
site_spp <- site_spp %>%
  group_by(site, species_functional_type) %>%
  mutate(priority = row_number()) %>%
  # Keep all species that have at least 3 plants
  mutate(priority = ifelse(n_plants > 2, 1, priority)) %>%
  data.frame()

# Remove any species that are lower priority
si <- si %>%
  left_join(select(site_spp, site, common_name, priority),
            by = c("site", "common_name")) %>%
  filter(priority == 1) %>%
  select(-priority)
site_spp <- site_spp %>%
  filter(priority == 1) %>%
  select(-priority)
  
# Site-species-phenophase summary
site_spp_ph <- si %>%
  group_by(site, common_name, phenophase_description) %>%
  summarize(n_plants = n_distinct(individual_id),
            first_yr = min(yr),
            last_yr = max(yr),
            n_yrs = n_distinct(yr),
            n_obs = n(),
            mean_int = round(mean(interval, na.rm = TRUE), 2),
            max_int = max(interval, na.rm = TRUE),
            .groups = "keep") %>%
  mutate(obs_per_yr = round(n_obs / n_yrs, 1)) %>%
  relocate(obs_per_yr, .after = "n_obs") %>%
  data.frame()
```

```{r}
#| label: site-spp
#| tbl-cap: Amount of filtered data available for each species at each site.

site_spp_t <- site_spp %>%
  mutate(site = str_to_upper(site),
         yr_range = paste(first_yr, "-", last_yr),
         phps = paste0(n_php, " (", leaf_php, ",", flower_php, 
                       ",", fruit_php, ")")) %>%
  relocate(yr_range, .before = "n_yrs") %>%
  select(-c(first_yr, last_yr, n_php, leaf_php, flower_php, fruit_php)) %>%
  kbl(col.names = c("Site", "Species", "Functional group", "No. plants",
                    "Year range", "No. years", "No. phenophases (leaf, flower, fruit)"),
      align = c(rep("r", 3), rep("c", 4))) %>%
  kable_styling(full_width = FALSE, font_size = 11)
site_spp_t
# write.table(site_spp_t, "clipboard", row.names = FALSE)
```

```{r summarize-intensity-cats}

# Create table summarizing amount of information per intensity category
intensity_cats <- si %>%
  group_by(class_id, intensity_label, intensity_type) %>%
  summarize(n = n(),
            n_spp = n_distinct(common_name),
            n_plants = n_distinct(individual_id),
            n_yrs = n_distinct(yr),
            values = paste(sort(unique(intensity_midpoint)), collapse = ", "),
            valuesq = paste(sort(unique(intensity_value)), collapse = ", "),
            .groups = "keep") %>%
  mutate(unique_values = ifelse(intensity_type == "qualitative", 
                                valuesq, values)) %>%
  select(-c(values, valuesq)) %>%
  data.frame()

# Identify categories that we want to exclude because:
  # Only one or two intensity values represented in dataset
  # Fewer than 50 observations across species, plants, and years
intensity_cats <- intensity_cats %>%
  mutate(exclude = case_when(
    str_count(unique_values, ",") < 2 ~ 1,
    n < 50 ~ 1, 
    .default = 0
  ))

# Remove categories from dataset and intensity category table
si <- si %>%
  left_join(select(intensity_cats, intensity_label, exclude), 
            by = "intensity_label") %>%
  filter(exclude == 0) %>%
  select(-exclude)
intensity_cats <- intensity_cats %>%
  filter(exclude == 0) %>%
  select(-exclude)

# Create column with logged intensity values (for plotting)
si <- si %>%
  mutate(intensity_midpoint_log = ifelse(intensity_midpoint == 0,
                                         log(intensity_midpoint + 0.01), 
                                         log(intensity_midpoint)))

# Create short name for intensity categories
intensity_cats <- intensity_cats %>%
  mutate(intensity_short = case_when(
    intensity_label == "No. breaking leaf buds" ~ "BreakingLeafBuds",
    intensity_label == "Leaf size (%)" ~ "LeafSize",
    intensity_label == "No. young leaves" ~ "YoungLeaves",
    intensity_label == "Leaf canopy fullness (%)" ~ "CanopyFullness",
    intensity_label == "Plant greeness (%)" ~ "Greenness",
    intensity_label == "Leaf canopy color (%)" ~ "CanopyColor",
    intensity_label == "No. flower heads" ~ "FlowerHeads",
    intensity_label == "No. flowers and flower buds" ~ "Flowers",
    intensity_label == "Open flowers (%)" ~ "OpenFlowers",
    intensity_label == "No. fruits" ~ "Fruits",
    intensity_label == "Ripe fruit (%)" ~ "Ripe fruit",
    intensity_label == "No. fruit/seed drop" ~ "FruitDrop",
    .default = NA
  ))

# Summarize data available for each plant, phenophase, and year (in part
# to figure out what data to include in GAMs). Recreating pl_ph_yr...
  # Going to use rle(phenophase_status) to understand the patterns:
    # length(rle$values) = number of 0/1 status sequences
    # first(rle$values) = state at first observation
    # last(rle$values) = state at last observation
pl_ph_yr <- si %>%
  arrange(site, individual_id, phenophase_id, observation_date) %>%
  group_by(site, common_name, individual_id, phenophase_description,
           intensity_label, class_id, yr) %>%
  summarize(nobs = n(),
            first_obs = min(day_of_year),
            last_obs = max(day_of_year),
            mean_int = round(mean(interval, na.rm = TRUE), 2),
            max_int = ifelse(nobs ==1, NA, max(interval, na.rm = TRUE)),
            n_inphase = sum(phenophase_status),
            # n_intvalue = sum(!is.na(intensity_value)),
            prop_inphase = round(n_inphase / nobs, 2),
            # prop_intvalue = round(n_intvalue / n_inphase, 2),
            n_states = length(rle(phenophase_status)$values),
            first_status = first(rle(phenophase_status)$values),
            last_status = last(rle(phenophase_status)$values),
            .groups = "keep") %>%
  data.frame()

# Summarize across species
# pl_ph_yr %>%
#   group_by(common_name) %>%
#   summarize(n = n(),
#             n_status0 = sum(prop_inphase < 1),
#             prop_status0 = round(n_status0 / n, 2),
#             n_states_mn = round(mean(n_states), 2),
#             n_states_min = min(n_states),
#             n_states_max = max(n_states),
#             prop_start0 = round(sum(first_status == 0) / n, 2),
#             prop_end0 = round(sum(last_status == 0) / n, 2), 
#             prop_00 = round(sum(first_status == 0 & last_status == 0) / n, 2),
#             .groups = "keep") %>%
#   data.frame() %>%
#   arrange(desc(n))

# Summarize across phenophases
# pl_ph_yr %>%
#   group_by(class_id, phenophase_description, intensity_label) %>%
#   summarize(n = n(),
#             n_status0 = sum(prop_inphase < 1),
#             prop_status0 = round(n_status0 / n, 2),
#             n_states_mn = round(mean(n_states), 2),
#             n_states_min = min(n_states),
#             n_states_max = max(n_states),
#             prop_start0 = round(sum(first_status == 0) / n, 2),
#             prop_end0 = round(sum(last_status == 0) / n, 2), 
#             prop_00 = round(sum(first_status == 0 & last_status == 0) / n, 2),
#             .groups = "keep") %>%
#   data.frame()

# Simpler summary across phenophases
php_summary <- pl_ph_yr %>%
  group_by(class_id, phenophase_description, intensity_label) %>%
  summarize(n_spp = n_distinct(common_name),
            n_plantyrs = n(),
            n_states_mn = round(mean(n_states), 2),
            n_states_max = max(n_states),
            prop_00 = round(sum(first_status == 0 & last_status == 0) / n_plantyrs, 2),
            .groups = "keep") %>%
  data.frame()

```

```{r plot-raw-intensity-data}

# Identify the min/max number of plants per species, intensity category, and 
# year to keep point size consistent among plots
nplants_size <- si %>%
  group_by(intensity_label, common_name, yr) %>%
  summarize(n_plants = n_distinct(individual_id), .groups = "keep") %>%
  data.frame()

for (i in 1:nrow(intensity_cats)) {

  si_int <- filter(si, intensity_label == intensity_cats$intensity_label[i])
  spps <- unique(si_int$common_name)

  # Remove observations where phenophase status is 1, but intensity value wasn't
  # provided (this creates breaks in plotted lines)
  si_int <- filter(si_int, !is.na(intensity_midpoint))

  # Plot logged values for numeric intensity categories
  if (si_int$intensity_type[1] == "number") {
    si_int <- si_int %>%
      mutate(yaxis = intensity_midpoint_log)
  } else {
    si_int <- si_int %>%
      mutate(yaxis = intensity_midpoint)
  }

  for (spp in spps) {
    
    # Create filename for png
    spp_nospace <- str_replace_all(spp, " ", "_")
    png_name <- paste0("output/intensities-by-spp-php-yr/intensities-",
                       intensity_cats$intensity_short[i], "-", spp_nospace, 
                       ".png")
    
    # Create ggplot object and save to file (if file doesn't already exist)
    if (!file.exists(png_name)) {

      si_int_spp <- filter(si_int, common_name == spp)
  
      ylab <- ifelse(si_int$intensity_type[1] == "number",
                     paste0("log(", str_to_lower(si_int$intensity_label[1]), ")"),
                     si_int$intensity_label[1])
      
      # Figures with lines connecting intensity measures for each individual
      # iplot <- ggplot(si_int_spp, aes(x = day_of_year, y = yaxis)) +
      #   geom_line(aes(color = factor(individual_id))) +
      #   facet_grid(yr ~ .) +
      #   theme(legend.position = "none") +
      #   labs(title = paste0(str_to_sentence(spp), ",  ", intensity_cats$intensity_label[i]),
      #        y = ylab, x = "Day of year")
      
      # Figures with lines and points, with size proportional to no. of plants 
      agg <- si_int_spp %>%
        group_by(yr, day_of_year, yaxis) %>%
        summarize(n_indiv = n(), .groups = "keep") %>%
        data.frame()

      iplot <- ggplot(agg, aes(x = day_of_year, y = yaxis)) +
        facet_grid(yr ~ .) +
        geom_line(data = si_int_spp, show.legend = FALSE, alpha = 0.5,
                  aes(x = day_of_year, y = yaxis, color = factor(individual_id))) +
        geom_point(data = agg,
                   aes(x = day_of_year, y = yaxis, size = n_indiv),
                   shape = 16, alpha = 0.4) +
        scale_size_continuous(limits = c(1, max(nplants_size$n_plants))) +
        labs(title = paste0(str_to_sentence(spp), ",  ", intensity_cats$intensity_label[i]),
             y = ylab, x = "Day of year") +
        theme_bw()
      iplot
      
      ggsave(png_name,
             plot = iplot,
             width = 6.5,
             height = 9,
             units = "in")
    }
  }
}
```

```{r}
#| label: php-summary
#| tbl-cap: Summary of data available for each phenophase and intensity category. 

php_summary_t <- php_summary %>%
  mutate(n_transitions_mn = n_states_mn - 1,
         n_transitions_max = n_states_max - 1) %>%
  select(-c(class_id, n_states_mn, n_states_max)) %>%
  relocate(prop_00, .after = "n_transitions_max") %>%
  kbl(col.names = c("Phenophase", "Intensity category", 
                    "No. species", "No. plant-years", 
                    "Mean no. status transitions per yr", 
                    "Max. no. status transitions per yr", 
                    "Prop. of plant-years that start and end out of phase"),
      align = c(rep("r", 2), rep("c", 5))) %>%
  kable_styling(full_width = FALSE, font_size = 11)
php_summary_t
# write.table(php_summary_t, "clipboard", row.names = FALSE)
```

## Using GAMs to describe seasonal changes in phenophase intensity

We wanted to model how phenophase intensity changes over the course of a season for various plant species and phenophases. Given that patterns are often more complex that that described by a simple linear or quadratic model, we used generalized additive models (GAMs) for this task.

One challenge in modeling these data is that intensity values (or intensity category midpoints) are not normally distributed. For numeric intensity categories (e.g., the number of breaking leaf buds or flowers), values can range from 0 (when the plant is not in the associated phenophase) to \>10,000, and the midpoints are not evenly distributed across that range. For example, the observed number of flowers on a plant can take one of the following values: 0, 1, 5, 50, 500, 5000, or 10,000 (each value is the approximate midpoint of a range). For percentage intensity categories (e.g., leaf canopy fullness or the % of flowers that are open), values are bounded by 0 and 100.

NEED TO REWORK!!!: We used the `mgcv` package in R to contruct GAM models. While the `gam()` function in this package allows the user to specifiy a non-Gaussian distribution and link function when fitting a model, alternative distributions were not suitable given the structure of our data. A Poisson distribution did not provide a good fit for our numeric data because non-zero values were infrequent and took only a few unique values that differed by orders of magnitude. A beta distribution with a logit link did not provide a good fit for our proportional data because we had an abundance of zero values, which are not compatible with the beta distribution (support on (0,1) and not \[0,1\]). To fit a beta distribution, we were required to "nudge" values slightly above zero, which caused significant biases in predicted values (see <https://www.robertkubinec.com/post/limited_dvs/>). Given these obstacles, we elected to transform intensity values prior to fitting a model, which enabled us to use Gaussian distributions in GAMs. Specifically, for numeric intensity values, we added a small amount (0.01) to zero values and log-transformed the data; for percentage intensity values, we added a small amount (0.01) to zero values, divided by 100, and logit-transformed the data. For reporting and visualizations, we backtransformed predicted values to the original scale for easier interpretation.

```{r gam-data}

# NEON sites had some years where monitoring started late (but note that this 
# may not matter for phenophases that occur later in the year)
  # BONA [quaking aspen]: 2017 and 2020 
  # DEJU [dwarf birch]: 2016 and 2020
  # SRER [velvet mesquite, creosote bush, desert zinnia]: 2016
si <- si %>%
  filter(!(site == "bona" & yr %in% c(2017, 2020))) %>%
  filter(!(site == "deju" & yr %in% c(2016, 2020))) %>%
  filter(!(site == "srer" & yr == 2016))
 
# Use a rule to exclude any species-phenophase combination where there's only one 
# year of data. For now, will keep the few combinations where we have one plant
# observed over multiple years.
si <- si %>%
  group_by(common_name, phenophase_description) %>%
  mutate(n_yrs = n_distinct(yr)) %>%
  ungroup() %>%
  filter(n_yrs > 1) %>%
  select(-n_yrs) %>%
  data.frame()

# Sort data and remove any observations with missing intensity values
gamdf <- si %>%
  arrange(class_id, phenophase_description, site, common_name, individual_id, 
          observation_date) %>%
  filter(!is.na(intensity_midpoint)) %>%
  mutate(intensity_short = case_when(
    intensity_label == "No. breaking leaf buds" ~ "BreakingLeafBuds",
    intensity_label == "Leaf size (%)" ~ "LeafSize",
    intensity_label == "No. young leaves" ~ "YoungLeaves",
    intensity_label == "Leaf canopy fullness (%)" ~ "CanopyFullness",
    intensity_label == "Plant greeness (%)" ~ "Greenness",
    intensity_label == "Leaf canopy color (%)" ~ "CanopyColor",
    intensity_label == "No. flower heads" ~ "FlowerHeads",
    intensity_label == "No. flowers and flower buds" ~ "Flowers",
    intensity_label == "Open flowers (%)" ~ "OpenFlowers",
    intensity_label == "No. fruits" ~ "Fruits",
    intensity_label == "Ripe fruit (%)" ~ "Ripe fruit",
    intensity_label == "No. fruit/seed drop" ~ "FruitDrop",
    .default = NA
  ))

# List of species-intensity category combinations
combos <- gamdf %>%
  mutate(plantyr = paste0(individual_id, "_", yr)) %>%
  group_by(class_id, intensity_label, intensity_type, common_name) %>%
  summarize(n_plantyrs = n_distinct(plantyr),
            n_plants = n_distinct(individual_id),
            n_yrs = n_distinct(yr),
            .groups = "keep") %>%
  data.frame()

# Create dataframe to hold estimates from GAM models:
combos_u <- combos %>%
  select(class_id, intensity_label, intensity_type, common_name, n_plants) %>%
  mutate(yr = NA)
gams <- gamdf %>%
  group_by(class_id, intensity_label, intensity_type, common_name, yr) %>%
  summarize(n_plants = n_distinct(individual_id),
            .groups = "keep") %>%
  data.frame() %>%
  rbind(combos_u) %>%
  arrange(class_id, common_name, yr) %>%
  mutate(k = NA,
         smooth = NA,
         model = NA,
         fyrs_p = NA,
         aic = NA,
         devexpl = NA,
         kcheck = NA,
         peak_date = NA, 
         peak_value = NA,
         # optimizer = NA, 
         convergence = NA)

```

```{r}
#| label: gam-data-summary
#| tbl-cap: Summary of data available for each intensity category and species. 

gam_data_t <- combos %>%
  select(-class_id) %>%
  kbl(col.names = c("Intensity category", "Intensity type", "Species",
                    "No. plant-years", "No. plants", "No. years"),
      align = c(rep("r", 3), rep("c", 3))) %>%
  kable_styling(full_width = FALSE, font_size = 11)
gam_data_t
# write.table(gam_data_t, "clipboard", row.names = FALSE)
```

```{r models-count-data}

# See project notes, but for now, using models in mgcv package for numeric data 
# aggregated over individual plants (using Gamma distribution after adjusting 
# zero values)

  # brms spline models were prohibitively slow...
  # ignoring 0s and using a gamma distribution (just modeling non-zeros) created weird patterns
  # converting intensities to ordered classes (0:5) and using a poisson or NB caused crazy SE/CIs
  # modeling original data with a ziGamma distribution (with glmmTMB) seems the
    # most appropriate, but get crazy SE/CIs

# List of numeric intensity categories
counts <- gamdf %>%
  filter(intensity_type == "number") %>%
  distinct(class_id, phenophase_description, intensity_label)

# Loop through intensity categories
for (i in 1:nrow(counts)) {

  # Extract data for that intensity category
  count1 <- filter(gamdf, intensity_label == counts$intensity_label[i])
  spps <- sort(unique(count1$common_name))
  
  # Loop through species
  for (spp in spps) {
    
    message("Running models for ", spp, ": ", counts$intensity_label[i])

    # Identify the rows of gams dataframe associated with species & intensity
    row1 <- which(gams$intensity_label == counts$intensity_label[i] &
                  gams$common_name == spp & is.na(gams$yr))
    rowyrs <- which(gams$intensity_label == counts$intensity_label[i] &
                    gams$common_name == spp & !is.na(gams$yr))
    
    # Extract data for that species
    intdf <- filter(count1, common_name == spp)
    
    # Make variables into factors
    intdf$fyr <- factor(intdf$yr)

    # Nudge intensity midpoint 0 values
    intdf <- intdf %>%
      mutate(midpoint_adj = case_when(
        intensity_midpoint == 0 ~ 0.01,
        .default = intensity_midpoint
      ))  

    # Aggregate data across individual plants within a year
    counts_yragg <- intdf %>%
      group_by(fyr, yr, day_of_year, midpoint_adj) %>%
      summarize(n_indiv = n(), .groups = "keep") %>%
      data.frame()
    
    # Set k value
    kval <- 20
    
    # Logical indicating whether to use a cyclic smooth (when observation date
    # range starts in first two weeks of the year and ends in the last two weeks)
    cubic_bs <- ifelse(min(intdf$day_of_year) <= 14 & max(intdf$day_of_year >= (365 - 14)),
                       "cc", "cr")
    
    # Extract and save model settings
    gams$k[c(rowyrs, row1)] <- kval
    gams$smooth[c(rowyrs, row1)] <- cubic_bs

    # Model with annual and global smooths ("GS" model in Pedersen et al. 2019).
    # Wrapping call in suppressWarnings since these models always spit out a 
    # warning about repeated 1-d smooths that we can safely ignore (according
    # to Gavin Simpson)
    suppressWarnings(
      m_gs <- gam(midpoint_adj ~ s(day_of_year, k = kval, bs = cubic_bs) +
                    s(day_of_year, fyr, k = kval, bs = "fs", xt = list(bs = cubic_bs), m = 1), 
                  weights = n_indiv/mean(n_indiv),
                  data = counts_yragg, method = "REML", 
                  family = Gamma(link = "log"), select = TRUE)
    )
    # summary(m_gs)
    
    # Extract and save model results
    gams$model[rowyrs] <- "GS"
    gams$fyrs_p[rowyrs] <- summary(m_gs)$s.table[2,"p-value"]
    gams$aic[rowyrs] <- round(AIC(m_gs), 2)
    gams$devexpl[rowyrs] <- round(summary(m_gs)$dev.expl * 100, 1)
    gams$kcheck[rowyrs] <- ifelse(any(k.check(m_gs)[, "p-value"] < 0.10),
                                  "problem", "ok")
    
    # Plot global smooth:
      # plot(m_gs, select = 1)
      # plot(m_gs, select = 1, trans = exp, shift = coef(m_gs)[1], 
      #      rug = FALSE, se = FALSE)
      # plot_predictions(m_gs, by = "day_of_year", exclude = "s(day_of_year,fyr)", 
      #                  type = "link", transform = exp) 
    # Note that the CI around the global effect is huge. Similar to: 
    # https://stats.stackexchange.com/questions/645096/interpretation-help-of-summary-from-basic-gam-models-with-random-smooths 
    # If we reduce both k's a lot, then the CI gets smaller, but the annual 
    # smooths don't seem like they fit the data well at all and the gam.check 
    # p-values are much smaller.
    
    # Using marginaleffects package to look at annual smooths. 
    # (need to use link and transform arguments to calculate properly and 
    # prevent CI's from extending below 0.)
      # plot_predictions(m_gs, by = c("day_of_year", "fyr"), type = "link", transform = exp)
      # plot_predictions(m_gs, by = c("day_of_year", "fyr", "fyr"), type = "link", transform = exp)
    # Note: can get dataframe with estimates by including draw = FALSE for 
    # original data or newdata

    # Model with annual smooths and NO global smooth ("S" model in Pedersen)
    # m_s <- gam(midpoint_adj ~ s(day_of_year, fyr, k = kval, bs = "fs",
    #                             xt = list(bs = cubic_bs)),
    #            weights = n_indiv/mean(n_indiv),
    #            data = counts_yragg, method = "REML",
    #            family = Gamma(link = "log"), select = TRUE)
    # summary(m_s)
    # plot_predictions(m_s, by = c("day_of_year", "fyr"))
    
    # Model with only a global smooth ("G" model in Pedersen; but keeping a 
    # yearly random effect in the model).
    m_g <- gam(midpoint_adj ~ s(day_of_year, k = kval, bs = cubic_bs) + s(fyr, bs = "re"), 
               weights = n_indiv/mean(n_indiv),
               data = counts_yragg, method = "REML", 
               family = Gamma(link = "log"), select = TRUE)
    # summary(m_g)
    # plot_predictions(m_g, by = c("day_of_year"))
    # gam.check(m_g)
    
    # Extract and save model results
    gams$model[row1] <- "G"
    gams$aic[row1] <- round(AIC(m_g), 2)
    gams$devexpl[row1] <- round(summary(m_g)$dev.expl * 100, 1)
    gamcheck_pvalues <- k.check(m_g)[, "p-value"]
    gamcheck_pvalues <- gamcheck_pvalues[!is.na(gamcheck_pvalues)]
    gams$kcheck[row1] <- ifelse(any(gamcheck_pvalues < 0.10), "problem", "ok")
    
    if (gams$kcheck[row1] == "problem") {
      warning("gam.check for ", spp, ":", counts$intensity_label[i],
              " (G) indicates potential problems with model fit.")
    }
    if (any(gams$kcheck[rowyrs] == "problem")) {
      warning("gam.check for ", spp, ":", counts$intensity_label[i],
              " (GS) indicates potential problems with model fit.")
    }

    # Calculating predictions (same results as marginaleffects::plot_predictions)
    # See helpful G. Simpson code here:
    # https://stats.stackexchange.com/questions/471267/plotting-gams-on-response-scale-with-multiple-smooth-and-linear-terms
    
    # Extract inverse link function
    ilink <- family(m_g)$linkinv
    
    # Global preds from G model (can get predictions for global smooth in GS 
    # model but the CIs are nonsensically huge)
    newdata_g <- data.frame(
      day_of_year = seq(min(counts_yragg$day_of_year), max(counts_yragg$day_of_year)),
      fyr = intdf$fyr[1])
    preds_g <- predict(m_g, newdata_g, type = "link", se.fit = TRUE, exclude = "s(fyr)")
    preds_g <- cbind(newdata_g, preds_g)
    preds_g <- preds_g %>%
      mutate(lwr_ci = ilink(fit - (2 * se.fit)),
             upr_ci = ilink(fit + (2 * se.fit)),
             fitted = ilink(fit))
    # Save date with maximum fitted value
    gams$peak_date[row1] <- preds_g$day_of_year[preds_g$fitted == max(preds_g$fitted)]
    gams$peak_value[row1] <- round(max(preds_g$fitted))
    
    # Global preds from GS model
    # newdata_GSg <- data.frame(
    #   day_of_year = seq(min(counts_yragg$day_of_year), max(counts_yragg$day_of_year)),
    #   fyr = counts_yragg$fyr[1]) # Need to have a value for fyr, but it isn't used
    # preds_GSg <- predict(m_gs, newdata_GSg, type = "link", se.fit = TRUE,
    #                  exclude = "s(day_of_year,fyr)")
    # preds_GSg <- cbind(newdata_GSg, preds_GSg)
    # preds_GSg <- preds_GSg %>%
    #   mutate(lwr_ci = ilink(fit - (2 * se.fit)),
    #          upr_ci = ilink(fit + (2 * se.fit)),
    #          fitted = ilink(fit))
    
    # Plot global smooth with raw data
    counts_agg <- intdf %>%
      group_by(day_of_year, midpoint_adj) %>%
      summarize(n_obs = n(), .groups = "keep") %>%
      data.frame()
    # ggplot(preds_g, aes(x = day_of_year, y = fitted)) +
    #   geom_ribbon(aes(ymin = lwr_ci, ymax = upr_ci), alpha = 0.2) +
    #   geom_point(data = counts_agg,
    #              aes(x = day_of_year, y = midpoint_adj, size = n_obs),
    #              shape = 16, alpha = 0.3, color = "forestgreen") +
    #   geom_line() +
    #   labs(x = "Day of year",
    #        y = intdf$intensity_label[1],
    #        size = "No. obs.",
    #        title = paste0(str_to_sentence(intdf$common_name[1]),
    #                         " (", str_to_upper(intdf$site[1]), ")")) +
    #   theme_bw()

    # Annual predictions (only for observed date range)
    counts_yragg$yr <- as.numeric(as.character(counts_yragg$fyr))
    for (yr in sort(unique(counts_yragg$yr))) {
      min_doy <- min(counts_yragg$day_of_year[counts_yragg$fyr == yr])
      max_doy <- max(counts_yragg$day_of_year[counts_yragg$fyr == yr])
      doys <- seq(min_doy, max_doy)
      if (yr == min(counts_yragg$yr)) {
        newdata_a <- data.frame(fyr = yr, day_of_year = doys)
      } else {
        newdata_a <- rbind(newdata_a, data.frame(fyr = yr, day_of_year = doys))
      }
    }
    newdata_a$fyr <- factor(newdata_a$fyr)
    # From GS model
    preds_a <- predict(m_gs, newdata_a, type = "link", se.fit = TRUE)
    preds_a <- cbind(newdata_a, preds_a)
    preds_a <- preds_a %>%
      mutate(lwr_ci = ilink(fit - (2 * se.fit)),
             upr_ci = ilink(fit + (2 * se.fit)),
             fitted = ilink(fit))
    peaks <- preds_a %>%
      group_by(fyr) %>%
      summarize(peak_date = day_of_year[fitted == max(fitted)],
                peak_value = max(fitted))
    gams$peak_date[rowyrs] <- peaks$peak_date
    gams$peak_value[rowyrs] <- round(peaks$peak_value)
    
    # Create bounded CIs for plots (useful if CIs get crazy high) 
    plotmax <- ifelse(max(intdf$intensity_midpoint) == 10001,
                      10000 * 2, max(intdf$intensity_midpoint) * 2)
    preds_a <- preds_a %>%
      mutate(upr_ci_b = ifelse(upr_ci > plotmax, plotmax, upr_ci))
    
    # Logical to indicate whether to use same y-axis in each year's panel
    same_yaxis <- FALSE
    
    if (same_yaxis) {
      ann_plot <- ggplot(data = preds_a, aes(x = day_of_year)) +
        facet_wrap(~fyr) +
        geom_ribbon(aes(ymin = lwr_ci, ymax = upr_ci_b), alpha = 0.25)
        # Don't expand upper end of y-axis (only needed if cutting off CIs)  
        if (max(preds_a$upr_ci) >= plotmax) {
          ann_plot <- ann_plot +
            scale_y_continuous(expand = expansion(mult = c(0.05, 0)))
        }
    } else {
      ann_plot <- ggplot(data = preds_a, aes(x = day_of_year)) +
        facet_wrap(~fyr, scales = "free_y") +
        geom_ribbon(aes(ymin = lwr_ci, ymax = upr_ci), alpha = 0.25)
    }
    ann_plot <- ann_plot +
      # geom_point(data = counts_yragg,
      #            aes(x = day_of_year, y = midpoint_adj, size = n_indiv),
      #            shape = 16, alpha = 0.3, color = "forestgreen") +
      geom_line(aes(y = fitted)) +
      labs(x = "Day of year", 
             y = intdf$intensity_label[1], 
             size = "No. plants",
             title = paste0(str_to_sentence(intdf$common_name[1]), 
                            " (", str_to_upper(intdf$site[1]), ")")) +
      theme_bw()

    # Plotting on the log scale makes thing look sooooo different.
      # yaxis_labels <- as.character(sort(unique(intdf$intensity_midpoint)))
      # yaxis_labels <- str_replace(yaxis_labels, "10001", "10000")
      # yaxis_breaks <- as.numeric(yaxis_labels)
      # 
      # ggplot(data = preds_a, aes(x = day_of_year)) +
      #   facet_wrap(~fyr, scales = "free_y") +
      #   geom_ribbon(aes(ymin = lwr_ci, ymax = upr_ci), alpha = 0.25) +
      #   geom_line(aes(y = fitted)) +
      #   geom_point(data = intdf, aes(y = midpoint_adj, x = day_of_year)) +
      #   scale_y_log10(breaks = yaxis_breaks,
      #                 labels = yaxis_labels)
    
    # Plot global and annual curves together
    gs_smooths <- ggplot(preds_g, aes(x = day_of_year, y = fitted)) +
      # geom_ribbon(aes(ymin = lwr_ci, ymax = upr_ci), alpha = 0.2) +
      geom_point(data = counts_yragg,
                 aes(x = day_of_year, y = midpoint_adj, size = n_indiv,
                     color = fyr),
                 shape = 16, alpha = 0.25) +
      # Using stuff below to include only whole numbers in size legend
      scale_size_continuous(
        range = c(1, 4), 
        breaks = function(x) {
          range_x <- range(counts_yragg$n_indiv, na.rm = TRUE)
          int_range <- seq(ceiling(range_x[1]), floor(range_x[2]), by = 1)
          # If too many breaks, thin them out
          if (length(int_range) > 5) {
            step <- ceiling(length(int_range) / 5)
            int_range[seq(1, length(int_range), by = step)]
          } else {
            int_range
          }
        }) +
      geom_line(data = preds_a, aes(x = day_of_year, y = fitted, color = fyr)) +
      geom_line(linewidth = 1) +
      labs(x = "Day of year", 
           y = intdf$intensity_label[1], 
           color = "Year",
           size = "No. obs.",
           title = paste0(str_to_sentence(intdf$common_name[1]), 
                            " (", str_to_upper(intdf$site[1]), ")")) +
      theme_bw() +
      theme(panel.grid = element_blank(),
            text = element_text(size = 8))
    # gs_smooths
    
    spp_nospace <- str_replace_all(spp, " ", "_")
    png_name <- paste0("output/gam-plots/",
                       intdf$intensity_short[1], "-", spp_nospace, 
                       ".png")
    
    ggsave(png_name,
           plot = gs_smooths,
           width = 6.5,
           height = 4,
           units = "in")
    
  }
}

```

```{r models-proportion-data}

# See project notes, but for now, using models in glmmTMB package for proportion
# data aggregated over individual plants 

  # brms/ordbetareg spline models were prohibitively slow...

# List of proportion intensity categories
proportions <- gamdf %>%
  filter(intensity_type == "percent") %>%
  distinct(class_id, phenophase_description, intensity_label)

# Loop through intensity categories
for (i in 1:nrow(proportions)) {

  # Extract data for that intensity category
  prop1 <- filter(gamdf, intensity_label == proportions$intensity_label[i] &
                    phenophase_description == proportions$phenophase_description[i])
  spps <- sort(unique(prop1$common_name))
  
  # Loop through species
  for (spp in spps) {

    message("Running models for ", spp, ": ", proportions$intensity_label[i])
    m_g <- NULL
    m_gs <- NULL

    # Identify the rows of gams dataframe associated with species & intensity
    row1 <- which(gams$intensity_label == proportions$intensity_label[i] &
                  gams$common_name == spp & is.na(gams$yr))
    rowyrs <- which(gams$intensity_label == proportions$intensity_label[i] &
                    gams$common_name == spp & !is.na(gams$yr))
    
    # Extract data for that species
    intdf <- filter(prop1, common_name == spp)
    
    # Make variables into factors
    intdf$fyr <- factor(intdf$yr)

    # Convert percentages to proportions
    intdf <- intdf %>%
      mutate(prop = intensity_midpoint / 100)

    # Aggregate data across individual plants within a year
    props_yragg <- intdf %>%
      group_by(fyr, yr, day_of_year, prop) %>%
      summarize(n_indiv = n(), .groups = "keep") %>%
      data.frame()

    # Set k value
    kval <- 20
    
    # Logical indicating whether to use a cyclic smooth (when observation date
    # range starts in first two weeks of the year and ends in the last two weeks)
    cubic_bs <- ifelse(min(intdf$day_of_year) <= 14 & max(intdf$day_of_year >= (365 - 14)),
                       "cc", "cr")
    
    # Extract and save model settings
    gams$k[c(rowyrs, row1)] <- kval
    gams$smooth[c(rowyrs, row1)] <- cubic_bs

    # Model with annual and global smooths ("GS" model in Pedersen et al. 2019).
    # Using tryCatch to identify any warnings
    m_gs <- glmmTMB(prop ~ s(day_of_year, k = kval, bs = cubic_bs) +
                      s(day_of_year, fyr, k = kval, bs = "fs", xt = list(bs = cubic_bs), m = 1), 
                    weights = n_indiv/mean(n_indiv),
                    data = props_yragg, REML = TRUE, family = ordbeta)
    # if (m_gs$fit$convergence != 0 | m_gs$sdr$pdHess == FALSE) {
    #   m_gs <- glmmTMB(prop ~ s(day_of_year, k = kval, bs = cubic_bs) +
    #                     s(day_of_year, fyr, k = kval, bs = "fs", xt = list(bs = cubic_bs), m = 1), 
    #                   weights = n_indiv/mean(n_indiv), 
    #                   control = glmmTMBControl(optimizer = optim, optArgs = list(method="nlminb")),
    #                   data = props_yragg, REML = TRUE, family = ordbeta)
    # }

    # Extract and save model results (not sure if/how to get some of these metrics)
    gams$model[rowyrs] <- "GS"
    # gams$fyrs_p[rowyrs] <- summary(m_gs)$s.table[2,"p-value"]
    gams$aic[rowyrs] <- round(AIC(m_gs), 2)
    # gams$devexpl[rowyrs] <- round(summary(m_gs)$dev.expl * 100, 1)
    # gams$kcheck[rowyrs] <- ifelse(any(k.check(m_gs)[, "p-value"] < 0.10),
    #                               "problem", "ok")
    # gams$optimizer[rowyrs] <- m_gs$obj$method
    gams$convergence[rowyrs] <- m_gs$fit$convergence 
    
    # Model with only a global smooth ("G" model in Pedersen; but keeping a 
    # yearly random effect in the model)
    m_g <- glmmTMB(prop ~ s(day_of_year, k = kval, bs = cubic_bs) + (1|fyr), 
                   weights = n_indiv/mean(n_indiv),
                   data = props_yragg, REML = TRUE, family = ordbeta)
    # if (m_g$fit$convergence != 0 | m_g$sdr$pdHess == FALSE) {
    #   m_g <- glmmTMB(prop ~ s(day_of_year, k = kval, bs = cubic_bs) + (1|fyr), 
    #                  weights = n_indiv/mean(n_indiv),
    #                  control = glmmTMBControl(optimizer = optim, optArgs = list(method="BFGS")),
    #                  data = props_yragg, REML = TRUE, family = ordbeta)
    # }

    # Extract and save model results (not sure if/how to get some of these metrics)
    gams$model[row1] <- "G"
    gams$aic[row1] <- round(AIC(m_g), 2)
    # gams$devexpl[row1] <- round(summary(m_g)$dev.expl * 100, 1)
    # gamcheck_pvalues <- k.check(m_g)[, "p-value"]
    # gamcheck_pvalues <- gamcheck_pvalues[!is.na(gamcheck_pvalues)]
    # gams$kcheck[row1] <- ifelse(any(gamcheck_pvalues < 0.10), "problem", "ok")
    # gams$optimizer[row1] <- m_g$obj$method
    gams$convergence[row1] <- m_g$fit$convergence 
    
    # Extract inverse link function
    ilink <- family(m_gs)$linkinv
    
    # Global preds from G model
    newdata_g <- data.frame(
      day_of_year = seq(min(props_yragg$day_of_year), max(props_yragg$day_of_year)),
      fyr = intdf$fyr[1],
      n_indiv = NA)
    preds_g <- predict(m_g, newdata_g, type = "link", se.fit = TRUE)
    preds_g <- cbind(newdata_g, preds_g)
    preds_g <- preds_g %>%
      mutate(lwr_ci = ilink(fit - (2 * se.fit)),
             upr_ci = ilink(fit + (2 * se.fit)),
             fitted = ilink(fit))
    # Save date with maximum fitted value
    gams$peak_date[row1] <- preds_g$day_of_year[preds_g$fitted == max(preds_g$fitted)][1]
    gams$peak_value[row1] <- round(max(preds_g$fitted), 2)
    
    # Plot global smooth with raw data
    props_agg <- intdf %>%
      group_by(day_of_year, prop) %>%
      summarize(n_obs = n(), .groups = "keep") %>%
      data.frame()
    # ggplot(preds_g, aes(x = day_of_year, y = fitted)) +
    #   geom_ribbon(aes(ymin = lwr_ci, ymax = upr_ci), alpha = 0.2) +
    #   geom_point(data = props_agg,
    #              aes(x = day_of_year, y = prop, size = n_obs),
    #              shape = 16, alpha = 0.3, color = "forestgreen") +
    #   geom_line() +
    #   labs(x = "Day of year",
    #        y = intdf$intensity_label[1],
    #        size = "No. obs.",
    #        title = paste0(str_to_sentence(intdf$common_name[1]),
    #                         " (", str_to_upper(intdf$site[1]), ")")) +
    #   theme_bw()

    # Annual predictions (only for observed date range)
    for (yr in sort(unique(props_yragg$yr))) {
      min_doy <- min(props_yragg$day_of_year[props_yragg$yr == yr])
      max_doy <- max(props_yragg$day_of_year[props_yragg$yr == yr])
      doys <- seq(min_doy, max_doy)
      if (yr == min(props_yragg$yr)) {
        newdata_a <- data.frame(fyr = yr, day_of_year = doys)
      } else {
        newdata_a <- rbind(newdata_a, data.frame(fyr = yr, day_of_year = doys))
      }
    }
    newdata_a$fyr <- factor(newdata_a$fyr)
    newdata_a$n_indiv <- NA
    # From GS model
    preds_a <- predict(m_gs, newdata_a, type = "link", se.fit = TRUE)
    preds_a <- cbind(newdata_a, preds_a)
    preds_a <- preds_a %>%
      mutate(lwr_ci = ilink(fit - (2 * se.fit)),
             upr_ci = ilink(fit + (2 * se.fit)),
             fitted = ilink(fit))
    peaks <- preds_a %>%
      group_by(fyr) %>%
      summarize(peak_date = day_of_year[fitted == max(fitted)][1],
                peak_value = max(fitted))
    gams$peak_date[rowyrs] <- peaks$peak_date
    gams$peak_value[rowyrs] <- round(peaks$peak_value, 2)
    
    # Plot global and annual curves together
    gs_smooths <- ggplot(preds_g, aes(x = day_of_year, y = fitted)) +
      # geom_ribbon(aes(ymin = lwr_ci, ymax = upr_ci), alpha = 0.2) +
      geom_point(data = props_yragg,
                 aes(x = day_of_year, y = prop, size = n_indiv,
                     color = fyr),
                 shape = 16, alpha = 0.25) +
      # Using stuff below to include only whole numbers in size legend
      scale_size_continuous(
        range = c(1, 4), 
        breaks = function(x) {
          range_x <- range(props_yragg$n_indiv, na.rm = TRUE)
          int_range <- seq(ceiling(range_x[1]), floor(range_x[2]), by = 1)
          # If too many breaks, thin them out
          if (length(int_range) > 5) {
            step <- ceiling(length(int_range) / 5)
            int_range[seq(1, length(int_range), by = step)]
          } else {
            int_range
          }
        }) +
      geom_line(data = preds_a, aes(x = day_of_year, y = fitted, color = fyr)) +
      geom_line(linewidth = 1) +
      labs(x = "Day of year", 
           y = intdf$intensity_label[1], 
           color = "Year",
           size = "No. obs.",
           title = paste0(str_to_sentence(intdf$common_name[1]), 
                            " (", str_to_upper(intdf$site[1]), ")")) +
      theme_bw() +
      theme(panel.grid = element_blank(),
            text = element_text(size = 8))
    # gs_smooths
    
    spp_nospace <- str_replace_all(spp, " ", "_")
    png_name <- paste0("output/gam-plots/",
                       intdf$intensity_short[1], "-", spp_nospace, 
                       ".png")
    
    ggsave(png_name,
           plot = gs_smooths,
           width = 6.5,
           height = 4,
           units = "in")

 }
}

```

```{r status-vs-intensity-1}

# List of proportion intensity categories
proportions <- gamdf %>%
  filter(intensity_type == "percent") %>%
  distinct(class_id, phenophase_description, intensity_label)

i = 5 # Open flowers

# Extract data for that intensity category
prop1 <- filter(gamdf, intensity_label == proportions$intensity_label[i] &
                  phenophase_description == proportions$phenophase_description[i])
spps <- sort(unique(prop1$common_name))
spp <- spps[9] # Velvet mesquite

# Extract data for that species
intdf <- filter(prop1, common_name == spp)
  
# Make variables into factors
intdf$fyr <- factor(intdf$yr)

# Convert percentages to proportions
intdf <- intdf %>%
  mutate(prop = intensity_midpoint / 100)

# Aggregate data across individual plants within a year
props_yragg <- intdf %>%
  group_by(fyr, yr, day_of_year, prop) %>%
  summarize(n_indiv = n(), .groups = "keep") %>%
  data.frame()

# Set k value
kval <- 10
    
# Logical indicating whether to use a cyclic smooth (when observation date
# range starts in first two weeks of the year and ends in the last two weeks)
cubic_bs <- ifelse(min(intdf$day_of_year) <= 14 & max(intdf$day_of_year >= (365 - 14)),
                   "cc", "cr")

# Model with only a global smooth
m_g <- glmmTMB(prop ~ s(day_of_year, k = kval, bs = cubic_bs),
               weights = n_indiv/mean(n_indiv),
               data = props_yragg, REML = TRUE, family = ordbeta)
ilink <- family(m_g)$linkinv

# Global preds from G model
newdata_g <- data.frame(
  day_of_year = seq(min(props_yragg$day_of_year), max(props_yragg$day_of_year)),
    n_indiv = NA)
preds_g <- predict(m_g, newdata_g, type = "link", se.fit = TRUE)
preds_g <- cbind(newdata_g, preds_g)
preds_g <- preds_g %>%
  mutate(lwr_ci = ilink(fit - (2 * se.fit)),
         upr_ci = ilink(fit + (2 * se.fit)),
         fitted = ilink(fit))

# Evaluate how intensity curve varies from curve explaining weekly 
# proportion of plants in phase?
intdf_status <- intdf %>%
  mutate(wk = week(observation_date)) %>%
  group_by(individual_id, fyr, wk) %>%
  summarize(status = max(phenophase_status), .groups = "keep") %>%
  group_by(fyr, wk) %>%
  summarize(prop = sum(status) / n(),
            n_plants = n(),
            .groups = "keep") %>%
  data.frame() %>%
  mutate(doy = wk * 7 - 3) %>%
  filter(wk < 53)

m_prop <- gam(prop ~ s(doy, k = kval, bs = cubic_bs),
              weights = n_plants,
              data = intdf_status, family = binomial,
              method = "REML")
summary(m_prop)

invlogit <- function(x) {
  exp(x) / (1 + exp(x))
}

newdata_p <- newdata_g %>%
  rename(n_plants = n_indiv,
         doy = day_of_year)
preds_p <- predict(m_prop, newdata_p, type = "link", se.fit = TRUE)
preds_p <- cbind(newdata_p, preds_p)
preds_p <- preds_p %>%
  mutate(lwr_ci = invlogit(fit - (2 * se.fit)),
         upr_ci = invlogit(fit + (2 * se.fit)),
         fitted = invlogit(fit)) 

p_prop <- ggplot(data = preds_p, aes(x = doy, y = fitted)) +
    geom_ribbon(aes(ymin = lwr_ci, ymax = upr_ci), alpha = 0.4) +
    geom_line() +
    scale_x_continuous(limits = c(0, 365)) +
    labs(y = "Proportion of plants in phase") +
    theme_bw() +
    theme(axis.text.x = element_blank(),
          axis.title.x = element_blank())
p_int <- ggplot(data = preds_g, aes(x = day_of_year, y = fitted)) +
    geom_ribbon(aes(ymin = lwr_ci, ymax = upr_ci), alpha = 0.4) +
    geom_line() +
    scale_x_continuous(limits = c(0, 365)) +
    labs(y = intdf$intensity_label[1], x = "Day of year") +
    theme_bw()
plot_grid(p_prop, p_int, ncol = 1, align = "v", axis = "lr")

```

```{r status-vs-intensity-2}

# List of proportion intensity categories
proportions <- gamdf %>%
  filter(intensity_type == "percent") %>%
  distinct(class_id, phenophase_description, intensity_label)

i = 4 # Canopy color

# Extract data for that intensity category
prop1 <- filter(gamdf, intensity_label == proportions$intensity_label[i] &
                  phenophase_description == proportions$phenophase_description[i])
spps <- sort(unique(prop1$common_name))
spp <- spps[2] # Dwarf birch

# Extract data for that species
intdf <- filter(prop1, common_name == spp)
  
# Make variables into factors
intdf$fyr <- factor(intdf$yr)

# Convert percentages to proportions
intdf <- intdf %>%
  mutate(prop = intensity_midpoint / 100)

# Aggregate data across individual plants within a year
props_yragg <- intdf %>%
  group_by(fyr, yr, day_of_year, prop) %>%
  summarize(n_indiv = n(), .groups = "keep") %>%
  data.frame()

# Set k value
kval <- 10
    
# Logical indicating whether to use a cyclic smooth (when observation date
# range starts in first two weeks of the year and ends in the last two weeks)
cubic_bs <- ifelse(min(intdf$day_of_year) <= 14 & max(intdf$day_of_year >= (365 - 14)),
                   "cc", "cr")

# Model with only a global smooth
m_g <- glmmTMB(prop ~ s(day_of_year, k = kval, bs = cubic_bs),
               weights = n_indiv/mean(n_indiv),
               data = props_yragg, REML = TRUE, family = ordbeta)
ilink <- family(m_g)$linkinv

# Global preds from G model
newdata_g <- data.frame(
  day_of_year = seq(min(props_yragg$day_of_year), max(props_yragg$day_of_year)),
    n_indiv = NA)
preds_g <- predict(m_g, newdata_g, type = "link", se.fit = TRUE)
preds_g <- cbind(newdata_g, preds_g)
preds_g <- preds_g %>%
  mutate(lwr_ci = ilink(fit - (2 * se.fit)),
         upr_ci = ilink(fit + (2 * se.fit)),
         fitted = ilink(fit))

# Evaluate how intensity curve varies from curve explaining weekly 
# proportion of plants in phase?
intdf_status <- intdf %>%
  mutate(wk = week(observation_date)) %>%
  group_by(individual_id, fyr, wk) %>%
  summarize(status = max(phenophase_status), .groups = "keep") %>%
  group_by(fyr, wk) %>%
  summarize(prop = sum(status) / n(),
            n_plants = n(),
            .groups = "keep") %>%
  data.frame() %>%
  mutate(doy = wk * 7 - 3) %>%
  filter(wk < 53)

m_prop <- gam(prop ~ s(doy, k = kval, bs = cubic_bs),
              weights = n_plants,
              data = intdf_status, family = binomial,
              method = "REML")
summary(m_prop)

invlogit <- function(x) {
  exp(x) / (1 + exp(x))
}

newdata_p <- newdata_g %>%
  rename(n_plants = n_indiv,
         doy = day_of_year)
preds_p <- predict(m_prop, newdata_p, type = "link", se.fit = TRUE)
preds_p <- cbind(newdata_p, preds_p)
preds_p <- preds_p %>%
  mutate(lwr_ci = invlogit(fit - (2 * se.fit)),
         upr_ci = invlogit(fit + (2 * se.fit)),
         fitted = invlogit(fit)) 

p_prop <- ggplot(data = preds_p, aes(x = doy, y = fitted)) +
    geom_ribbon(aes(ymin = lwr_ci, ymax = upr_ci), alpha = 0.4) +
    geom_line() +
    scale_x_continuous(limits = c(200, 300)) +
    labs(y = "Proportion of plants in phase") +
    theme_bw() +
    theme(axis.text.x = element_blank(),
          axis.title.x = element_blank())
p_int <- ggplot(data = preds_g, aes(x = day_of_year, y = fitted)) +
    geom_ribbon(aes(ymin = lwr_ci, ymax = upr_ci), alpha = 0.4) +
    geom_line() +
    scale_x_continuous(limits = c(200, 300)) +
    labs(y = intdf$intensity_label[1], x = "Day of year") +
    theme_bw()
plot_grid(p_prop, p_int, ncol = 1, align = "v", axis = "lr")

```

```{r derived-metrics}

# Can only use Ellen's data for open flowers (no. flowers * % open).
# Start with 3 species
dm <- si %>%
  filter(site == "ellen") %>%
  filter(phenophase_description %in% c("Flowers or flower buds", "Open flowers")) %>%
  filter(common_name %in% c("crocus", "forsythia", "sugar maple")) %>%
  select(individual_id, common_name, phenophase_description, observation_date, 
         phenophase_status, yr, class_id, intensity_midpoint, intensity_label)
dmw <- dm %>%
  mutate(phenophase = ifelse(phenophase_description == "Flowers or flower buds",
                             "flowers", "open")) %>%
  rename(intensity = intensity_midpoint) %>%
  tidyr::pivot_wider(
    id_cols = c(individual_id, common_name, observation_date),
    names_from = phenophase,
    names_glue = "{phenophase}_{.value}",
    values_from = c(phenophase_status, intensity)
  ) %>%
  mutate(nopen = round(flowers_intensity * open_intensity / 100)) %>%
  filter(!is.na(nopen)) %>%
  mutate(doy = yday(observation_date)) %>%
  mutate(yr = year(observation_date)) %>%
  data.frame() 
# count(dmw, nopen)

# Plot crocus data
crocus <- dmw %>%
  filter(common_name == "crocus") %>%
  mutate(fyr = factor(yr))
ggplot(data = crocus, aes(x = doy, y = nopen)) +
  geom_line() +
  facet_wrap(~fyr) +
  labs(x = "Day of year", y = "No. open flowers", title = "Crocus")

# Plot forsythia data
forsyth <- dmw %>%
  filter(common_name == "forsythia") %>%
  mutate(fyr = factor(yr)) %>%
  mutate(individual_id = factor(individual_id))
ggplot(data = forsyth, aes(x = doy, y = nopen)) +
  geom_line(aes(color = individual_id)) +
  facet_wrap(~fyr) +
  labs(x = "Day of year", y = "No. open flowers", title = "Forsythia",
       color = "Plant ID")

# Plot sugar maple data
suma <- dmw %>%
  filter(common_name == "sugar maple") %>%
  mutate(fyr = factor(yr)) %>%
  mutate(individual_id = factor(individual_id))
ggplot(data = suma, aes(x = doy, y = nopen)) +
  geom_line(aes(color = individual_id)) +
  facet_wrap(~fyr) +
  labs(x = "Day of year", y = "No. open flowers", title = "Sugar maple",
       color = "Plant ID")

```


```{r mgcv-old}
#| eval: false

# Transform intensity data (numeric/percentage separately then merge back together)
numeric_no0 <- 0.01
percentage_no0 <- 0.01
gamdf_n <- gamdf %>%
  filter(intensity_type == "number") %>%
  mutate(intensity_midpoint_no0 = case_when(
    intensity_midpoint == 0 ~ numeric_no0,
    intensity_midpoint != 0 ~ intensity_midpoint
  )) %>%
  mutate(intensity_t = log(intensity_midpoint_no0))
gamdf_p <- gamdf %>%
  filter(intensity_type == "percent") %>%
  mutate(intensity_midpoint_no0 = case_when(
    intensity_midpoint == 0 ~ percentage_no0,
    intensity_midpoint != 0 ~ intensity_midpoint
  )) %>%
  mutate(intensity_midpoint_no0 = intensity_midpoint_no0 / 100) %>%
  mutate(intensity_t = log(intensity_midpoint_no0 / (1 - intensity_midpoint_no0)))
gamdf <- rbind(gamdf_n, gamdf_p)
# check:
# count(gamdf, intensity_type, intensity_midpoint, intensity_midpoint_no0, intensity_t)

# List of species-intensity category combinations
combos <- gamdf %>%
  mutate(plantyr = paste0(individual_id, "_", yr)) %>%
  group_by(intensity_label, intensity_type, common_name) %>%
  summarize(n_plantyrs = n_distinct(plantyr),
            n_plants = n_distinct(individual_id),
            n_yrs = n_distinct(yr),
            .groups = "keep") %>%
  data.frame()

# Function to create list for y axis on original scale
yaxis_breaks <- function(intensity_type, data = intdf) {
  yaxis = list()
  yaxis$desired_breaks = sort(unique(intdf$intensity_midpoint_no0))
  if (intensity_type == "number") {
    yaxis$labels_t = log(yaxis$desired_breaks)
  } else {
    yaxis$labels_t = log(yaxis$desired_breaks / (1 - yaxis$desired_breaks))
  }
  yaxis$desired_labels = sort(unique(intdf$intensity_midpoint))
  yaxis
}

# TODO: accomodate combos with 1 year or 1 plants...

# Set up table to hold results (and save images with logical names)
# combos columns, no. plant-years, model (one smooth, annual smooths), deviance explained, GCV,
# predicted peak, quantiles...

# Loop through species/intensities, fitting GAMs, ....

# for (i in 1:nrow(combos)) {
i = 17
intdf <- gamdf %>%
  filter(intensity_label == combos$intensity_label[i],
         common_name == combos$common_name[i])

intdf$individual_id <- factor(intdf$individual_id)
intdf$fyr <- factor(intdf$yr)
# intdf$indyr <- factor(paste0(intdf$individual_id, "_", intdf$yr))

# Logical indicating whether to use a cyclic smooth (when observation date
# range starts in first two weeks of the year and ends in the last two weeks)
cubic_bs <- ifelse(min(intdf$day_of_year) <= 14 & max(intdf$day_of_year >= (365 - 14)),
                   "cc", "cr")

# Fit same smooth each year, random intercepts for individual plants without 
# any accounting for year (and many plants monitored in multiple years)
  # m0 <- gam(resp ~ s(day_of_year, bs = "cc", k = 20) +  s(individual_id, bs = "re"),
  #           method = "REML", data = intdf, select = TRUE)
  # summary(m0)
# I'm not sure this is valid given that we're interested in plant-specific
# annual curves. If year isn't in the model anywhere then we're creating one
# curve for each plant by combining data across years, which seems wrong.

# Fit same smooth each year, with random intercepts for each plant-year combo
m1 <- gam(intensity_t ~ s(day_of_year, bs = cubic_bs, k = 20) +  
            s(individual_id, fyr, bs = "re"),
          method = "REML", data = intdf, select = TRUE)
summary(m1)

  # Get names of smooth terms
  # sapply(m1$smooth, "[[", "label")
  #  "s(day_of_year)"       "s(individual_id,fyr)" 

  # Make predictions using mgcv::predict.gam()
  # see: https://stackoverflow.com/questions/51634953/gam-with-gp-smoother-predict-at-new-locations/51635487#51635487.
  # Checked that values for individual_id and year don't matter (but get warning if not in orig dataset)
  m1_new <- data.frame(day_of_year = min(intdf$day_of_year):max(intdf$day_of_year),
                       individual_id = intdf$individual_id[1], 
                       fyr = intdf$fyr[1]) 
  m1_p <- predict(m1, newdata = m1_new, type = "terms", 
                  terms = "s(day_of_year)", se.fit = TRUE)
  # Simplify to dataframe and calculate CI
  m1_preds <- data.frame(day_of_year = m1_new$day_of_year,
                         fit = attr(m1_p, "constant") + rowSums(m1_p$fit),
                         se.fit = rowSums(m1_p$se.fit)) %>%
    mutate(lcl = fit - 1.96 * se.fit,
           ucl = fit + 1.96 * se.fit)

  # Use function to get y-axis values
  yaxis <- yaxis_breaks(intensity_type = combos$intensity_type[i])

  # Create ggplot object
  m1_plot <- ggplot() +
    geom_point(data = intdf, aes(x = day_of_year, y = intensity_t), 
               shape = 19, color = "gray") +
    # geom_ribbon(data = m1_preds, aes(x = day_of_year, ymin = lcl, ymax = ucl), 
    #             fill = "#a1d99b", alpha = 0.5) +
    geom_line(data = m1_preds, aes(x = day_of_year, y = fit), 
              color = "#a1d99b", linewidth = 1.5) +
    labs(x = "Day of year", 
         y = combos[i, 1],
         title = paste0(intdf$intensity_label[1], ", ", intdf$common_name[1], 
                        " (", length(unique(intdf$individual_id)), " plants; ", 
                        length(unique(intdf$yr)), " years)")) +
    scale_y_continuous(breaks = yaxis$labels_t,
                       labels = yaxis$desired_labels) +
    theme_bw()
  m1_plot  

  # Using marginaleffects package to get predictions
  m1_preds_me <- predictions(m1,
                  newdata = data.frame(
                    day_of_year = min(intdf$day_of_year):max(intdf$day_of_year),
                    individual_id = intdf$individual_id[1],
                    fyr = intdf$fyr[1]),
                  exclude = "s(individual_id,fyr)") 
  # Confirmed that I can change individual_id and fyr and get same results
  # Confirmed that results are almost identical to that from predict.gam (CIs 
  # slightly different)

# Fit different smooths each year (fixed effects), with random intercepts for 
# individual plants.
m2 <- gam(intensity_t ~ fyr + 
            s(day_of_year, by = fyr) +
              # , bs = cubic_bs, k = 30) +
            s(individual_id, bs = "re"),
          method = "REML", data = intdf, select = TRUE)
summary(m2)

  # Get names of smooth terms
  # (m2_terms <- sapply(m2$smooth, "[[", "label"))
  #  "s(day_of_year):fyr2018" "s(day_of_year):fyr2019" "s(day_of_year):fyr2021" 
  #  "s(day_of_year):fyr2022" "s(individual_id)"   

  # Make predictions using mgcv::predict.gam()
  # Create a dataframe to hold predictions from more complex model
  for (yr in sort(unique(intdf$yr))) {
    min_doy <- min(intdf$day_of_year[intdf$fyr == yr])
    max_doy <- max(intdf$day_of_year[intdf$fyr == yr])
    doys <- seq(min_doy, max_doy)
    if (yr == min(intdf$yr)) {
      m2_new <- data.frame(fyr = yr, day_of_year = doys)
    } else {
      m2_new <- rbind(m2_new, data.frame(fyr = yr, day_of_year = doys))
    }
  }
  m2_new$individual_id <- intdf$individual_id[1]
  
  m2_p <- predict(m2, newdata = m2_new, type = "terms", 
                  exclude = m2_terms[length(m2_terms)], se.fit = TRUE)
  
  # Simplify to dataframe and calculate CI
  m2_preds <- data.frame(fyr = m2_new$fyr,
                         day_of_year = m2_new$day_of_year,
                         fit = attr(m2_p, "constant") + rowSums(m2_p$fit),
                         se.fit = rowSums(m2_p$se.fit)) %>%
    mutate(lcl = fit - 1.96 * se.fit,
           ucl = fit + 1.96 * se.fit)
  m2_preds$fyr <- factor(m2_preds$fyr)

  # Create ggplot object
  m2_plot <- ggplot(data = m2_preds,
                    aes(x = day_of_year, group = fyr, color = fyr, fill = fyr)) +
    geom_point(data = intdf, aes(x = day_of_year, y = intensity_t, group = NULL), 
               shape = 19, color = "gray", show.legend = FALSE) +
    # geom_ribbon(data = m2_preds, aes(ymin = lcl, ymax = ucl), 
    #             linewidth = 0, alpha = 0.3) +
    geom_line(data = m2_preds, aes(x = day_of_year, y = fit, group = fyr)) +
    labs(x = "Day of year", 
         y = paste0("log(", combos[i, 1], ")"),
         title = paste0(intdf$intensity_label[1], ", ", intdf$common_name[1], 
                        " (", length(unique(intdf$individual_id)), " plants; ", 
                        length(unique(intdf$yr)), " years)"),
         # fill = "Year",
         color = "Year") +
    scale_y_continuous(breaks = yaxis$labels_t,
                       labels = yaxis$desired_labels) +
    theme_bw()
  m2_plot  

  # Using marginaleffects package to get predictions
  m2_preds_me <- predictions(m2, newdata = m2_new, exclude = "s(individual_id)") 
  # CI are somewhat narrower here than when I calculated them using predict.gam


# Compare AIC values
AIC(m1, m2)

# Fit individual smooths for each year and plant? Hangs up indefinitely....
# https://stackoverflow.com/questions/68659805/mgcv-gam-more-than-one-variable-in-by-argument-smooth-varying-by-more-than-1
  # m3 <- gam(intensity_midpoint_log ~ fyr + individual_id +
  #             s(day_of_year, by = interaction(fyr, individual_id), bs = "cr", k = 20),
  #           method = "REML", data = intdf, select = TRUE)
  # summary(m3)

# Looking at intensity data that are proportions/percentages
i = 34 # open flowers, dwarf birch (24 plants, 4 years)
intdf <- gamdf %>%
  filter(intensity_label == combos$intensity_label[i],
         common_name == combos$common_name[i])

intdf$individual_id <- factor(intdf$individual_id)
intdf$fyr <- factor(intdf$yr)

# Logical indicating whether to use a cyclic smooth (when observation date
# range starts in first two weeks of the year and ends in the last two weeks)
cubic_bs <- ifelse(min(intdf$day_of_year) <= 14 & max(intdf$day_of_year >= (365 - 14)),
                   "cc", "cr")

# Fit same smooth each year, with random intercepts for each plant-year combo.
# Specifying a beta regression to deal with data in (0, 1)
intdf$resp <- intdf$resp / 100
m1 <- gam(resp ~ s(day_of_year, bs = cubic_bs, k = 20) +  
            s(individual_id, fyr, bs = "re"),
          method = "REML", family = betar(link = "logit"), 
          select = TRUE, data = intdf)
summary(m1)

  # Get names of smooth terms
  sapply(m1$smooth, "[[", "label")
  #  "s(day_of_year)"       "s(individual_id,fyr)" 

  # Make predictions using mgcv::predict.gam()
  m1_new <- data.frame(day_of_year = min(intdf$day_of_year):max(intdf$day_of_year),
                       individual_id = intdf$individual_id[1], 
                       fyr = intdf$fyr[1])
  m1_p <- predict(m1, newdata = m1_new, type = "terms", 
                  terms = "s(day_of_year)", se.fit = TRUE)
  
  # Simplify to dataframe and calculate CI
  m1_preds <- data.frame(day_of_year = m1_new$day_of_year,
                         fitl = attr(m1_p, "constant") + rowSums(m1_p$fit),
                         se.fit = rowSums(m1_p$se.fit)) %>%
    mutate(fit = exp(fitl) / (1 + exp(fitl)),
           lcll = fitl - 1.96 * se.fit,
           ucll = fitl + 1.96 * se.fit,
           lcl = exp(lcll) / (1 + exp(lcll)),
           ucl = exp(ucll) / (1 + exp(ucll)))

  # Create ggplot object
  m1_plot <- ggplot() +
    geom_point(data = intdf, aes(x = day_of_year, y = resp), shape = 19, color = "gray") +
    geom_ribbon(data = m1_preds, aes(x = day_of_year, ymin = lcl, ymax = ucl), 
                fill = "#a1d99b", alpha = 0.5) +
    geom_line(data = m1_preds, aes(x = day_of_year, y = fit)) +
    labs(x = "Day of year", 
         y = combos[i, 1],
         title = paste0(intdf$intensity_label[1], ", ", intdf$common_name[1], 
                        " (", length(unique(intdf$individual_id)), " plants; ", 
                        length(unique(intdf$yr)), " years)")) +
    theme_bw()
  m1_plot  

  # Using marginaleffects package to get predictions
  m1_preds_me <- predictions(m1,
                  newdata = data.frame(
                    day_of_year = min(intdf$day_of_year):max(intdf$day_of_year),
                    individual_id = intdf$individual_id[500],
                    fyr = 2020),
                  type = "response",
                  exclude = "s(individual_id,fyr)") 

  # Get equivalent predictions from both methods, but the predictions seem off -
  # they don't approach the bounds/0, even though they definitely should. 
  # Trying a model where I tranform proportional data to real scale first
  
  intdf$resp <- ifelse(intdf$intensity_midpoint == 0,
                       0.001, intdf$intensity_midpoint)
  intdf$resp <- intdf$resp / 100
  intdf$respR <- log(intdf$resp / (1 - intdf$resp))
  
  m1trans <- gam(respR ~ s(day_of_year, bs = cubic_bs, k = 20) +  
                 s(individual_id, fyr, bs = "re"),
                 method = "REML", select = TRUE, data = intdf)
  summary(m1trans)

  m1_p <- predict(m1trans, newdata = m1_new, type = "terms", 
                  terms = "s(day_of_year)", se.fit = TRUE)
  
  # Simplify to dataframe and calculate CI
  m1_preds <- data.frame(day_of_year = m1_new$day_of_year,
                         fitl = attr(m1_p, "constant") + rowSums(m1_p$fit),
                         se.fit = rowSums(m1_p$se.fit)) %>%
    mutate(fit = exp(fitl) / (1 + exp(fitl)),
           lcll = fitl - 1.96 * se.fit,
           ucll = fitl + 1.96 * se.fit,
           lcl = exp(lcll) / (1 + exp(lcll)),
           ucl = exp(ucll) / (1 + exp(ucll)))

  # Create ggplot object
  m1_plot <- ggplot() +
    geom_point(data = intdf, aes(x = day_of_year, y = resp), shape = 19, color = "gray") +
    geom_ribbon(data = m1_preds, aes(x = day_of_year, ymin = lcl, ymax = ucl), 
                fill = "#a1d99b", alpha = 0.5) +
    geom_line(data = m1_preds, aes(x = day_of_year, y = fit)) +
    labs(x = "Day of year", 
         y = combos[i, 1],
         title = paste0(intdf$intensity_label[1], ", ", intdf$common_name[1], 
                        " (", length(unique(intdf$individual_id)), " plants; ", 
                        length(unique(intdf$yr)), " years)")) +
    theme_bw()
  m1_plot  
  # This is much more like what I expected, with the caveat that there is
  # essentially no uncertainty around the curve once it gets close to 0
  
  m1_preds_me <- predictions(m1trans,
                  newdata = data.frame(
                  day_of_year = min(intdf$day_of_year):max(intdf$day_of_year),
                    individual_id = intdf$individual_id[500],
                    fyr = 2020),
                  exclude = "s(individual_id,fyr)") 
  m1_preds_me2 <- as.data.frame(m1_preds_me) %>%
    mutate(estimateP = exp(estimate) / (1 + exp(estimate)),
           conf.lowP = exp(conf.low) / (1 + exp(conf.low)),
           conf.highP = exp(conf.high) / (1 + exp(conf.high)))
  # Same
  
# Fit different smooths each year (fixed effects), with random intercepts for 
# individual plants.
m2trans <- gam(respR ~ fyr + 
               s(day_of_year, by = fyr, bs = cubic_bs, k = 20) +
               s(individual_id, bs = "re"),
               method = "REML", select = TRUE, data = intdf)
summary(m2trans)

  # Get names of smooth terms
  (m2_terms <- sapply(m2trans$smooth, "[[", "label"))
  #  "s(day_of_year):fyr2018" "s(day_of_year):fyr2019" "s(day_of_year):fyr2021" 
  #  "s(day_of_year):fyr2022" "s(individual_id)"   

  # Make predictions using mgcv::predict.gam()
  # Create a dataframe to hold predictions from more complex model
  for (yr in sort(unique(intdf$yr))) {
    min_doy <- min(intdf$day_of_year[intdf$fyr == yr])
    max_doy <- max(intdf$day_of_year[intdf$fyr == yr])
    doys <- seq(min_doy, max_doy)
    if (yr == min(intdf$yr)) {
      m2_new <- data.frame(fyr = yr, day_of_year = doys)
    } else {
      m2_new <- rbind(m2_new, data.frame(fyr = yr, day_of_year = doys))
    }
  }
  m2_new$individual_id <- intdf$individual_id[1]
  
  m2_p <- predict(m2trans, newdata = m2_new, type = "terms", 
                  exclude = m2_terms[length(m2_terms)], se.fit = TRUE)
  
  # Simplify to dataframe and calculate CI
  m2_preds <- data.frame(fyr = m2_new$fyr,
                         day_of_year = m2_new$day_of_year,
                         fitl = attr(m2_p, "constant") + rowSums(m2_p$fit),
                         se.fit = rowSums(m2_p$se.fit)) %>%
    mutate(fit = exp(fitl) / (1 + exp(fitl)),
           lcll = fitl - 1.96 * se.fit,
           ucll = fitl + 1.96 * se.fit,
           lcl = exp(lcll) / (1 + exp(lcll)),
           ucl = exp(ucll) / (1 + exp(ucll)))
  m2_preds$fyr <- factor(m2_preds$fyr)

  # Create ggplot object
  m2_plot <- ggplot(data = m2_preds,
                    aes(x = day_of_year, group = fyr, color = fyr, fill = fyr)) +
    geom_point(data = intdf, aes(x = day_of_year, y = resp, group = NULL), 
               shape = 19, color = "gray", show.legend = FALSE) +
    # geom_ribbon(data = m2_preds, aes(ymin = lcl, ymax = ucl),
    #             linewidth = 0, alpha = 0.3) +
    geom_line(data = m2_preds, aes(x = day_of_year, y = fit, group = fyr)) +
    labs(x = "Day of year", 
         y = combos[i, 1],
         title = paste0(intdf$intensity_label[1], ", ", intdf$common_name[1], 
                        " (", length(unique(intdf$individual_id)), " plants; ", 
                        length(unique(intdf$yr)), " years)"),
         # fill = "Year",
         color = "Year") +
    theme_bw()
  m2_plot  

  # Using marginaleffects package to get predictions
  m2_preds_me <- predictions(m2trans, newdata = m2_new, exclude = "s(individual_id)") 
  m2_preds_me2 <- as.data.frame(m2_preds_me) %>%
    mutate(estimateP = exp(estimate) / (1 + exp(estimate)),
           conf.lowP = exp(conf.low) / (1 + exp(conf.low)),
           conf.highP = exp(conf.high) / (1 + exp(conf.high)))



# }

```